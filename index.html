<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>蝎子菜菜~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="蝎子菜菜~">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="蝎子菜菜~">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="蝎子菜菜~" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+KR:100,300,400,700&amp;subset=korean" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <!--<div id="banner"></div>-->
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        <a href="/" id="main-nav-title" class="main-nav-link">蝎子菜菜~</a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives/">Archives</a>
        
          <a class="main-nav-link" href="/about/">about</a>
        
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-C++基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/30/C++%E5%9F%BA%E7%A1%80/">C++基础</a>
    </h1>
  

        <a href="/2019/11/30/C++%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2019-11-30T09:02:28.265Z" itemprop="datePublished">2019-11-30</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h3 id="头文件、名称空间的解释"><a href="#头文件、名称空间的解释" class="headerlink" title="头文件、名称空间的解释"></a>头文件、名称空间的解释</h3><p>头文件<code>#include&lt;bits/stdc++.h&gt;</code>包含了c++所有头文件；</p>
<p><code>using namespace std</code> 如果没有引用这句话，那么写代码的时候要写成这样:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;n;</span></pre></td></tr></table></figure>

<h3 id="控制格式输入输出"><a href="#控制格式输入输出" class="headerlink" title="控制格式输入输出"></a>控制格式输入输出</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>setw()</code>/<code>cout.width()</code></td>
<td>输出数据的宽度</td>
</tr>
<tr>
<td><code>setfill()</code></td>
<td>设置填充字符</td>
</tr>
<tr>
<td>setiosflags()/resetiosflags()</td>
<td>对齐方式</td>
</tr>
<tr>
<td>setprecision()</td>
<td>输出数据的精度</td>
</tr>
<tr>
<td>setbase()</td>
<td>转换为某进制</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> x=<span class="number">10</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">float</span> n=<span class="number">0.0123</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;setfill(<span class="string">'0'</span>)&lt;&lt;setw(<span class="number">5</span>)&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;setprecision(<span class="number">10</span>)&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;setiosflags(ios::scientific)&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//用科学记数法输出 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;setiosflags(ios::right)&lt;&lt;setw(<span class="number">10</span>)&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//居右显示 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;setbase(<span class="number">8</span>)&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//八进制输出 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;hex&lt;&lt;<span class="number">255</span>;<span class="comment">//或者用c++的格式控制符dec、oct、hex设置默认的输入输出进制 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a><code>const</code>变量</h3><p>C语言中会用<code>#define</code>定义<u>变量</u>；</p>
<p>C++里面用<code>const</code> 这个限定符定义<u>常量</u>；</p>
<h3 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h3><p>string只能用<code>cin</code>和 <code>cout</code>处理，不能用C语言的输入输出；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">"hello "</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s2=s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;s;<span class="comment">//空格就为分隔符结束输入</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//或者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">getline(<span class="built_in">cin</span>,s);<span class="comment">//可以接受一整行字符串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s3=s1+s2; <span class="comment">//拼接直接用+号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s4=s1.substr(<span class="number">4</span>);<span class="comment">//截取从开始到4的字符子串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s5=s1=substr(<span class="number">2</span>,<span class="number">4</span>);<span class="comment">//截取从下标2到4的字符子串</span></span></pre></td></tr></table></figure>

<p>可以直接进行<font color=red>日期型的比较</font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name,birth,maxn,minn,<span class="built_in">max</span>=<span class="string">"1814/09/06"</span>,<span class="built_in">min</span>=<span class="string">"2014/09/06"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">cin</span>&gt;&gt;name&gt;&gt;birth;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span>(birth&gt;=<span class="string">"1814/09/06"</span>&amp;&amp;birth&lt;=<span class="string">"2014/09/06"</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">		x++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span>(birth&gt;=<span class="built_in">max</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">			<span class="built_in">max</span>=birth;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">			maxn=name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span>(birth&lt;=<span class="built_in">min</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">			<span class="built_in">min</span>=birth;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">			minn=name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>查找函数find()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">string</span> s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="number">4</span>)==<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"存在4"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(s.fine(<span class="number">4</span>,<span class="number">3</span>)==<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"从第三个位置查找，也存在4"</span>;<span class="comment">//若不存在！=-1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct"></a>结构体struct</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">string</span> name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> no;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;;<span class="comment">//注意分号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span>[10];</span><span class="comment">//C语言中一定要struct，c++可省略</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="引用和传值的区别"><a href="#引用和传值的区别" class="headerlink" title="引用和传值的区别"></a>引用和传值的区别</h3><p>引用符号&amp;和取地址运算符&amp;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>&#123;<span class="comment">//传入的是n的引用，相当于直接对n进行了操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    a=<span class="number">99</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    func(n);<span class="comment">//n从0变成了99</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;<span class="comment">//传入的是0这个值，且函数没有返回任何值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    a=<span class="number">99</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    func(n);<span class="comment">//并不会改变n的值，还是0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>###　bitset位运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">bitset</span>&lt;5&gt; b(<span class="string">"11"</span>);<span class="comment">//5表示5个二进位</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//初始化方式：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//bitset&lt;5&gt; b;都为0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//bitset&lt;5&gt; b(u);u为unsigned int,如果n=111,则初始化为11100</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">///bitset&lt;5&gt; b(s); s为字符串，如"1101"-&gt;"10110"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//bitset&lt;5&gt; b(s, pos, n);从字符串s[pos]开始，n位长度 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cout</span>&lt;&lt;b[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;b.any();<span class="comment">//是否存在1的二进制位</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;b.none();<span class="comment">//b中不存在1吗</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;b.count();<span class="comment">//b中1的二进制的个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;b.<span class="built_in">size</span>();<span class="comment">//b中二进制为的个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;b.test(<span class="number">2</span>);<span class="comment">//b测试下标为2处是否二进制位为1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    b.<span class="built_in">set</span>(<span class="number">4</span>);<span class="comment">//把b的下标为4处置1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    b.reset();<span class="comment">//所有位归零</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    b.reset(<span class="number">3</span>);<span class="comment">//b的下标3处归零</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    b.flip();<span class="comment">//b的所有二进制位逐位取反</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    unsighed <span class="keyword">long</span> a=b.to_ulong();<span class="comment">//b转换位unsigned long类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行结果：<img src="C:%5CUsers%5C57069%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569668652891.png" alt="1569668652891"></p>
<h3 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h3><p>对一个数组int arr[]、vector进行排序，vector是容器，要用v.begin()和v.end()表示头尾；而int arr[]用arr表示数组的首<br>地址，arr+n表示尾部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">//从大到小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//return a&lt;b; 从小到大</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//不能是&lt;=或者&gt;=，（实际上等于号加了也是毫无意义，sort是不稳定的排序），否则可能会出现段错误</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>);    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i];    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());   <span class="comment">//默认从小到大排序</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    sort(arr, arr + <span class="number">10</span>, cmp);  <span class="comment">//调用从大到小排序的函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行结果：<img src="C:%5CUsers%5C57069%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569669843638.png" alt="1569669843638"></p>
<h4 id="应用：结构体排序"><a href="#应用：结构体排序" class="headerlink" title="应用：结构体排序"></a>应用：结构体排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span><span class="comment">//定义一个结构体stu，number表示学号，score表示分数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> number;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> score;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(stu a,stu b)</span></span>&#123;<span class="comment">//cmp函数，返回值是boo1，传入的参数类型应该是结构体stu类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(a.score!=b.score)<span class="comment">//如果学生分数不同，就按照分数从大到小排列</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> a.score&gt;b.score;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span><span class="comment">//如果学生分数相同，就按照学号从小到大排列</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//有时候这种简单的if-e1se语句我喜欢直接用一个c语言里面的三目运算符表示~</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(stu a,stu b)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> a.score!=b.score? a.score&gt;b.score:a.number&lt;b.number;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="cctype头文件里的函数"><a href="#cctype头文件里的函数" class="headerlink" title="cctype头文件里的函数"></a>cctype头文件里的函数</h3><figure class="highlight plain"><figcaption><span>(大小写字母)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;islower()&#96;&#96;&#96;（小写字母）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;isupper()&#96;&#96;&#96;（大写字母）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;isalnum()&#96;&#96;&#96;（字母大写小写+数字）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;isblank()&#96;&#96;&#96;（space和\t）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#96;&#96;isspace()&#96;&#96;（space、\t、\r、\n）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;tolower()&#96;&#96;&#96;转换为小写</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;c++</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">if(isalpha(c))&#123;&#x2F;&#x2F;如果c是字母</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;&quot;c is alpha&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">char a&#x3D;&#39;A&#39;；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">char t&#x3D;tolower(a)；&#x2F;&#x2F;将c字符转化为小写字符赋值给t，如果c本身就是小写字符也没有</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">关系~</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;t；&#x2F;&#x2F;此处t为‘a&#39;</span></pre></td></tr></table></figure>

<p><img src="https://cdn1.liuchuo.net/wp-content/uploads/2017/01/QQ20170118-163639@2x-768x316.png" alt="img"></p>
<h3 id="c-11"><a href="#c-11" class="headerlink" title="c++11"></a>c++11</h3><p>C++11是2011年官方为C++语言带来的新语法新标准，C++11为C++语言带来了很多好用的新特性，比如auto、to_string0函数、stoi、stof、unordered_map、unordered_set之类的~现在大多数O]都是支持C++11语法的，有些编译器在使用的时候需要进行一些设置才能使用C++11中的语法，否则可能会导致编译器上编译不通过无法运行。</p>
<h4 id="①auto"><a href="#①auto" class="headerlink" title="①auto"></a>①auto</h4><p>auto是C++11里面的新特性，可以让编译器根据初始值类型直接推断变量的类型。比如这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a=<span class="number">100</span>;<span class="comment">//x判断为int遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y=<span class="number">1.5</span>;<span class="comment">//y判断为double变量</span></span></pre></td></tr></table></figure>

<p>在STL中使用迭代器遍历的时候，可以用auto代替vector<int>::iterator，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//本来set的迭代器遍历要这样写：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//现在可以直接替换成这样的写法：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但是devc用auto会编译失败<br>解决①：替换成后者<br>解决②：菜单栏中工具-编译选项-编译器-编译时加入-std=c++11。</p>
<p>第二种方法可以在devc里完全使用c++11</p>
<h4 id="②to-string、sto-x"><a href="#②to-string、sto-x" class="headerlink" title="②to_string、sto-x"></a>②to_string、sto-x</h4><p>to_string（）可以把int、float、double等类型变量转化为string型变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">string</span> s1=to_string(<span class="number">123</span>);<span class="comment">//将123转换为字符串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">string</span> s2=to_string(<span class="number">4.5</span>);<span class="comment">//将4.5转换成字符串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1+s2&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//拼接s1,s2合起来输出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,(s1+s2).c_str());<span class="comment">//如果是C语言输出，要加.c_str()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p>stoi、stod可以将字符串string转化为对应的int型、double型变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">string</span> str=<span class="string">"123"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> a=stoi(str);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    str=<span class="string">"123.44"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">double</span> b=stod(str);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt;b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>stoi如果遇到的是非法输入（比如stoi（&quot;123.4&quot;），123.4不是一个int型变量）：</strong><br>1.会自动截取最前面的数字，直到遇到不是数字为止<br>（所以说如果是浮点型，会截取前面的整数部分）</p>
<p>2.如果最前面不是数字，会运行时发生错误</p>
<p><strong>stod如果是非法输入：</strong><br>1.会自动截取最前面的浮点数，直到遇到不满足浮点数为止<br>2.如果最前面不是数字或者小数点，会运行时发生错误<br>3.如果最前面是小数点，会自动转化后在前面补0</p>
<p><strong>不仅有stoi、stod两种，相应的还有：</strong><br>stof(string to float)<br>stold(string to long double)<br>stol(string to long)<br>stoll(string to long long)<br>stoul(string to unsigned long)<br>stoull(string to unsigned long long)</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a=<span class="number">99.5</span>,b=<span class="number">10.6</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c=<span class="string">'@'</span>,d=<span class="string">'#'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义指针必须带*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> *p1 =&amp;a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p2=&amp;c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改指针变量的值，赋值时不必带'*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">p1=&amp;b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">p2=&amp;d;</span></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5C57069%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191128085639601.png" alt="image-20191128085639601"></p>
<p> p1、p2 的类型分别是<code>float*</code>和<code>char*</code>，而不是<code>float</code>和<code>cha</code> </p>
<h2 id="对星号-的总结"><a href="#对星号-的总结" class="headerlink" title="对星号*的总结"></a>对星号<code>*</code>的总结</h2><p>在我们目前所学到的语法中，星号<code>*</code></p>
<ul>
<li>表示乘法，例如<code>int a = 3, b = 5, c;  c = a * b;</code>，这是最容易理解的。</li>
<li>表示定义一个指针变量，以和普通变量区分开，例如<code>int a = 100;  int *p = &amp;a;</code>。</li>
<li>表示获取指针指向的数据，是一种间接操作，例如<code>int a, b, *p = &amp;a;  *p = 100;  b = *p;</code> </li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> week&#123; Mon = <span class="number">1</span>, Tues = <span class="number">2</span>, Wed = <span class="number">3</span>, Thurs = <span class="number">4</span>, Fri = <span class="number">5</span>, Sat = <span class="number">6</span>, Sun = <span class="number">7</span> &#125;;</span></pre></td></tr></table></figure>



<h2 id="敲重点的STL！！"><a href="#敲重点的STL！！" class="headerlink" title="敲重点的STL！！"></a>敲重点的STL！！</h2><h3 id="vector动态数组"><a href="#vector动态数组" class="headerlink" title="vector动态数组"></a>vector动态数组</h3><p>与C语言 arr[] 的区别：C语言的定义数组的长度不能随意改变，而动态数组vector<u>容器</u>可以设置数组的长度、在末尾增加新的数据、在中间插入新的值、长度任意改变</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;<span class="comment">//没有分配大小，v.size=0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">v.resize(<span class="number">8</span>) <span class="comment">//分配长度为8，但是8个元素都为0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//或者直接分配</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">8</span>,<span class="number">1</span>);<span class="comment">//把8个值都初始化为1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;v[o];<span class="comment">//访问就像数组，使用下标</span></span></pre></td></tr></table></figure>

<h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><table>
<thead>
<tr>
<th>函数</th>
<th>函数解释</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>v.front()</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        a.push_back(i);<span class="comment">//在a的末尾添加第i个元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=a.<span class="built_in">begin</span>();i!=a.<span class="built_in">end</span>();i++)<span class="comment">//使用迭代器的方式访问vector</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cout</span>&lt;&lt;*i&lt;&lt;<span class="string">" "</span>;<span class="comment">//访问元素的值要对it指针取值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行结果：<img src="C:%5CUsers%5C57069%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569665250871.png" alt="1569665250871"></p>
<ol>
<li>a.begin() 是一个指针，指向容器的第一个元素</li>
<li>a.end()指向容器器的<u>最后一个元素的<strong>后一个位置</strong></u>，所以迭代器指针 it 的for循环判断条件是 it != a.end() 。</li>
</ol>
<h3 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h3><p>set集合里面的元素是不重复的，且会按照从小到大排序</p>
<h4 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h4><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    s.insert(<span class="number">1</span>);<span class="comment">//插入1；</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;*(s.<span class="built_in">begin</span>())&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        s.insert(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    	<span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; (s.<span class="built_in">find</span>(<span class="number">1</span>) != s.<span class="built_in">end</span>()) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//查找1这个元素，若有返回1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    s.erase(<span class="number">1</span>);<span class="comment">//删除了1这个元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; (s.<span class="built_in">find</span>(<span class="number">1</span>) != s.<span class="built_in">end</span>()) &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行结果：<img src="C:%5CUsers%5C57069%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569665678968.png" alt="1569665678968"></p>
<h3 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h3><p>map映射容器的元素数据是由一一对应的键值和映射数据组成的。</p>
<p>插入元素的键值不允许重复，且会自动排序。</p>
<p><img src="C:%5CUsers%5C57069%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569666085112.png" alt="1569666085112"></p>
<p>####　常用操作</p>
<table>
<thead>
<tr>
<th>常用操作函数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向map头部的迭代器</td>
</tr>
<tr>
<td>clear()</td>
<td>删除所有元素</td>
</tr>
<tr>
<td>count(elem)</td>
<td>返回指定元素出现的次数</td>
</tr>
<tr>
<td>empty()</td>
<td>如果map为空则返回true</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向map末尾的迭代器</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>erase()</td>
<td></td>
</tr>
<tr>
<td>find</td>
<td></td>
</tr>
<tr>
<td>get_allocator()</td>
<td></td>
</tr>
<tr>
<td>equal_range()</td>
<td></td>
</tr>
</tbody></table>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;<span class="comment">//定义一个键是string型，值是int型的空map m</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    m[<span class="string">"sherry"</span>]=<span class="number">1</span>;<span class="comment">//插入键为sherry，值为1的键值对</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;m[sherry]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//若存在，输出值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;m[herry]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//不存在，输出0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it=m.<span class="built_in">begin</span>();it!=m.<span class="built_in">end</span>();it++) &#123;             </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;         </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;<span class="comment">//键用it-&gt;first获取，值用it-&gt;second获取</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;m.<span class="built_in">begin</span>()-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;m.<span class="built_in">begin</span>()-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//输出第一个元素的键和值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;m.rbegin()-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;m.rbegin()-&gt;second&lt;&lt;<span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//输出最后一个元素的键和值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;m.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//输出map的元素个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行结果：<img src="C:%5CUsers%5C57069%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569667138144.png" alt="1569667138144"></p>
<h3 id="stack栈"><a href="#stack栈" class="headerlink" title="stack栈"></a>stack栈</h3><p>特点：先进后出</p>
<h4 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h4><table>
<thead>
<tr>
<th>常用操作函数</th>
<th>解释</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>top()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>push()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pop()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>size()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>empty()</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        q.push(n);<span class="comment">//依次压入队列q中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;q.front()&lt;&lt;<span class="string">" "</span>&lt;&lt;q.back()&lt;&lt;<span class="string">" "</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//访问队首元素、队尾元素并输出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    q.pop();<span class="comment">//移除队首元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;q.front();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行结果：<img src="C:%5CUsers%5C57069%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569667622281.png" alt="1569667622281"></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><h5 id="①unordered-map-set的使用"><a href="#①unordered-map-set的使用" class="headerlink" title="①unordered_map/set的使用"></a>①unordered_map/set的使用</h5><p>unordered_map在头文件#include <unordered map>中，unordered_set在头文件#include<unordered_set>中</p>
<p>unordered_map/unordered_set和map/set，map/set会按照键值对的键key/元素进行排序，而unordered map/unordered set<u><strong>省去了这个排序</strong></u>的过程，但不是按照插入顺序排序，直接是<strong>无序</strong>的，如果偶尔刷题时候用map或者set<strong><u>超时了，可以考虑用</u></strong>这两者缩短代码运行时间、提高代码效率，用法和map、set是一样的。</p>
<p>###　刷pat经常会遇到的坑</p>
<ol>
<li><p>定义界限太小</p>
</li>
<li><p>if-if-if语句和if-else if-else if两种的不同情况</p>
</li>
<li><p>do-while和while的两种情况</p>
</li>
<li><p>如果赋值for是从1开始，排序的sort函数也要（a+1,a+1+n)</p>
</li>
<li><p>换存储容器时，注意字符型与整型之间的转换，string s-&gt;int a[],里面的元素要 <code>s[i]-&#39;0&#39;</code>，反之<code>s[i]+&#39;0&#39;</code></p>
</li>
<li><pre><code class="c++"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>{
    <span class="keyword">if</span>(a%b==<span class="number">0</span>) <span class="keyword">return</span> b;
    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);
}<span class="comment">//求最小公约数</span></code></pre>
<p>备注：<font color="red">最小公倍数*最大公约数=两个数相乘</font></p>
</li>
<li></li>
</ol>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="http://yoursite.com/2019/11/30/C++%E5%9F%BA%E7%A1%80/" data-id="ck3lclaaa0001qkuy1x166uki" class="article-share-link">Share</a>-->
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机组成" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">计算机组成</a>
    </h1>
  

        <a href="/2019/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" class="article-date">
  <time datetime="2019-11-30T09:02:21.257Z" itemprop="datePublished">2019-11-30</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h1 id="计算机组成原理思维导图"><a href="#计算机组成原理思维导图" class="headerlink" title="计算机组成原理思维导图"></a>计算机组成原理思维导图</h1><h1 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h1><h2 id="第一章-计算机系统概论"><a href="#第一章-计算机系统概论" class="headerlink" title="第一章 计算机系统概论"></a>第一章 计算机系统概论</h2><p><img src="C:%5CUsers%5C57069%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1570952947494.png" alt="1570952947494"></p>
<h3 id="冯诺依曼型计算机特点"><a href="#冯诺依曼型计算机特点" class="headerlink" title="冯诺依曼型计算机特点"></a>冯诺依曼型计算机特点</h3><ul>
<li>1.计算机由<font color=red>运算器，控制器，存储器，输入和输出设备</font>5部分组成</li>
<li>2.采用<strong>存储程序</strong>的方式，<u>程序</u>和<u>数据</u>放在同一个存储器中，并以<u>二进制</u>表示。</li>
<li>3.指令由<u>操作码</u>和<u>地址码</u>组成</li>
<li>4.指令在存储器中按执行顺序存放，由指令计数器(即程序计数器PC)指明要执行的指令所在的储存单元地址，一般按顺序递增，但可按运算结果或外界条件而改变</li>
<li>5.机器以<u>运算器</u>为中心，输入输出设备与存储器间的数据传送都通过运算器<h3 id="区别以运算器为中心的计算机还是存储器的方法"><a href="#区别以运算器为中心的计算机还是存储器的方法" class="headerlink" title="区别以运算器为中心的计算机还是存储器的方法"></a>区别以运算器为中心的计算机还是存储器的方法</h3></li>
<li>看输入设备能否直接与存储器相连，是的话就是以存储器为中心<h3 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h3></li>
</ul>
<p><img src="C:%5CUsers%5C57069%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1570951749608.png" alt="1570951749608"></p>
<p><img src="C:%5CUsers%5C57069%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1570951775334.png" alt="1570951775334"></p>
<ul>
<li><p>硬件</p>
<ul>
<li><p>结构</p>
<p>  <img src="C:%5CUsers%5C57069%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1570951989076.png" alt="1570951989076"></p>
</li>
<li><p>主要技术指标</p>
<ul>
<li><p>响应时间：越短，吞吐量越大</p>
<ul>
<li>从提交到获得CPU响应所经历的时间</li>
</ul>
</li>
<li><p>主频：机器内部主时钟的频率，常用单位：Hz…</p>
</li>
<li><p>吞吐量</p>
<ul>
<li>对网络、设备、端口、虚电路或其他设施，单位时间内成功地传送数据的数量（以比特、字节、分组等测量，信息流入处理流出的<strong>速率</strong>，取决于<strong>主存</strong>的<strong>存取周期</strong>）。</li>
</ul>
</li>
<li><p>机器字长</p>
<ul>
<li>CPU一次能处理的数据的位数，与CPU的寄存器位数有关。不能单从精度和数的表示范围来考虑。</li>
</ul>
</li>
<li><p>存储容量</p>
<ul>
<li><p>存储容量＝存储单元个数×存储字长</p>
<p>PS: MAR位数一反映存储单元的个数，MDR的位数一存储字长。</p>
</li>
</ul>
</li>
<li><p>运算速度</p>
<ul>
<li>MIPS：每秒可执行百万条指令数（每秒可执行800万条指令，记作8MIPS）</li>
<li>CPl：执行一条指令所需的CPU时钟周期数（主频的倒数）</li>
<li>FLOPS：每秒执行的浮点运算次数。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>软件</p>
<ul>
<li>系统软件<ul>
<li>用来管理整个计算机系统 <ul>
<li>语言处理程序</li>
<li>操作系统</li>
<li>服务性程序</li>
<li>数据库管理系统</li>
<li>网络软件</li>
</ul>
</li>
</ul>
</li>
<li>应用软件<ul>
<li>按任务需要编制成的各种程序<h2 id="第三章-运算方法和运算部件"><a href="#第三章-运算方法和运算部件" class="headerlink" title="第三章 运算方法和运算部件"></a>第三章 运算方法和运算部件</h2><h3 id="数据的表示方法和转换"><a href="#数据的表示方法和转换" class="headerlink" title="数据的表示方法和转换"></a>数据的表示方法和转换</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>机器数正0负1</p>
<ul>
<li>符号数值化的带符号二进制数，称为机器数。</li>
</ul>
</li>
<li><p>真值:符号位加绝对值</p>
</li>
<li><p>余三码:在8421码的基础上，把每个编码都加上0011</p>
<ul>
<li>当两个余三码想加不产生进位时，应从结果中减去0011;产生进位时，应将进位信号送入高位，本位加0011</li>
</ul>
</li>
<li><p>格雷码:任何两个相邻编码只有1个二进制位不同，而其余3个二进制位相同</p>
</li>
<li><p>8421码</p>
<ul>
<li>权值从高到低为8、4、2、1<ul>
<li>算术运算时，需对运算结果进行修正。</li>
<li>方法：如果小于、等于(100</li>
<li>1)2，不需要修正；否则加6修正<h3 id="带符号的二进制数据在计算机中的表示方法及加减法运算"><a href="#带符号的二进制数据在计算机中的表示方法及加减法运算" class="headerlink" title="带符号的二进制数据在计算机中的表示方法及加减法运算"></a>带符号的二进制数据在计算机中的表示方法及加减法运算</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>原码</p>
<ul>
<li>定义<ul>
<li>最高位为符号位0/1+数值的绝对值形式</li>
</ul>
</li>
<li>特点<ul>
<li>（1）值+0，-0的原码分别为00000、10000，形式不唯一，两者不相等；</li>
<li>（2）正数的原码码值随着真值增长而增长<ul>
<li>负数的原码码值随着真值增长而减少</li>
</ul>
</li>
<li>（3）n+1位原码表示定点整数范围－(2n－1)——2n－1<ul>
<li>n+1位原码表示定点小数范围 －(1－2－n)——1－2－n</li>
</ul>
</li>
</ul>
</li>
<li>运算<ul>
<li>绝对值相加减，由数值大小决定运算结果符号</li>
</ul>
</li>
</ul>
</li>
<li><p>补码</p>
<ul>
<li>定义，特点和运算<ul>
<li>运算:<br>结果不超过机器所能表示范围时，[X+Y]补=[X]补+[Y]补<br>减法运算:<br>[X–Y]补=[X+(–Y)]补=[X]补+[–Y]补</li>
<li>结论<ul>
<li>负数的补数＝模＋负数</li>
<li>互为补数的绝对值相加＝模</li>
<li>在补数中，减法运算即加法运算</li>
</ul>
</li>
<li>定义<ul>
<li>定义法，即[X]补=2·符号位+X     （MOD  2）</li>
<li>X为正数，则符号0+X的绝对值；X为负数，则X的绝对值取反+1。</li>
</ul>
</li>
<li>特点<ul>
<li>数值零的补码表示唯一</li>
<li>正数补码码值随着真值增大而增大，负数补码码值随着真值增大而增大</li>
<li>n+1位补码所表示定点整数范围－ 2n——2n－1，n+1位补码所表示定点小数范围－1——1－2－n</li>
</ul>
</li>
</ul>
</li>
<li>加法运算逻辑事例<ul>
<li>过程</li>
<li>加减法运算的溢出处理<ul>
<li>溢出定义<ul>
<li>当运算结果超出机器数所能表示的范围</li>
</ul>
</li>
<li>加减中，可能产生溢出的情况<ul>
<li>可能出现溢出<ul>
<li>同号数相加</li>
<li>异号数相减</li>
</ul>
</li>
<li>不可能出现溢出<ul>
<li>异号数相加</li>
<li>同号数相减</li>
</ul>
</li>
</ul>
</li>
<li>判断溢出的方法<ul>
<li>法一：当符号相同两数相加，结果符号和加数（或被加数）不相同，则溢出<ul>
<li>fa,fb表示两操作数（A,B）的符号位,fs为结果的符号位</li>
</ul>
</li>
<li>法二：任意符号相加，如果C=Cf，则结果正确，否则溢出；<ul>
<li>C为数值最高位的进位，Cf为符号位的进位</li>
</ul>
</li>
<li>法三：采用双符号相加，如果fs1=fs2，则结果正确，否则溢出；<ul>
<li>运算结果的符号位为fs2；</li>
<li>多符号位的补码，叫做变形补码；</li>
<li>如果采用双符号位，当数为小数时，模m=4;当数为整数时，模m=2的n+2次方</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>反码</p>
<ul>
<li>定义<ul>
<li>a.定义法，即[X]反=(2-2-n)·符号位+X   (MOD  2-2-n)</li>
<li>b.X是正数，[X]反=[X]原；X是负数，符号+数值取反。</li>
</ul>
</li>
<li>特点<ul>
<li>数值零的反码表示不唯一</li>
<li>正数反码码值随着真值增大而增大，负数反码码值随着真值增大而增大</li>
<li>n+1位反码所表示定点整数范围－ (2n－1)——2n－1，n+1位反码所表示定点小数范围－(1－2－n)——1－2－n</li>
</ul>
</li>
<li>加减运算特点<ul>
<li>在机器数范围内，反码运算满足[X+Y]反=[X]反+[Y]反<br>，[X－Y]反=[X]反+[－Y]反</li>
</ul>
</li>
<li>反码运算在最高位有进位时，要在最低位+1，此时要多进行一次加法运算，增加了复杂性，又影响了速度，因此很少采用</li>
<li>由于反码运算是以2-2的-次方为模，所以，当最高位有进位而丢掉进位(即2)时，要在最低位+/-1</li>
</ul>
</li>
<li><p>移码</p>
<ul>
<li>由来及窍门<ul>
<li>为了从码值直接判断对应真值的大小，所以引进移码</li>
<li>[X]补的符号位取反，即得[X]移 </li>
</ul>
</li>
<li>特点<ul>
<li>最高位是符号位，1表示正，0表示负</li>
<li>数据0有唯一的编码</li>
<li>移码码值随着真值增大而增大</li>
<li>n+1位移码所表示定点整数范围－ 2n——2n－1， n+1位移码所表示定点小数范围－1——1－2－n</li>
<li>计算机中，移码常用于表示阶码，故只执行加、减运算</li>
<li>计算机中，移码运算公式需要对结果进行修正</li>
</ul>
</li>
<li>浮点数的阶码运算<ul>
<li>移码定义:[X]移=2的n次方+X</li>
<li>补码定义:[X]补=2的n+1次方+Y</li>
<li>阶码求和公式<ul>
<li>[X]移+[Y]补=[X+Y]移  mod2的n+1次方</li>
<li>[X]移+[-Y]补=[X-Y]移</li>
<li>判溢方法<ul>
<li>双符号位参加运算，最高符号位恒置0</li>
<li>当结果最高符号位=1则溢出<ul>
<li>低位符号=0，则上溢；低位符号=1，则下溢；</li>
</ul>
</li>
<li>当结果最高符号位=0则未溢出<ul>
<li>低位符号=0，负数；低位符号=1，正数</li>
</ul>
</li>
</ul>
</li>
<li>说明:如果阶码运算的结果溢出，上述条件不成立。此时，使用双符号位的阶码加法器，并规定移码的第二个符号位，即最高符号位恒用0参加加减运算，则溢出条件是结果的最高符号位为1。此时低位符号为0时，表明结果上溢;为1时，表明结果下溢。当最高符号位为0时，表明没有溢出，低位符号位为1，表明结果为正;为0时表明结果为负。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>补，反，原，移码的相互转换</p>
<ul>
<li>反码-》原码<ul>
<li>方法：符号位不变，正数不变，负数数值部分取反。</li>
</ul>
</li>
<li>补码-》原码<ul>
<li>方法1：正数不变，负数数值部分求反加1。</li>
<li>方法2：串行转换<ul>
<li>从最后开始数，遇到第一个“1”，除第一个“1”不变，前面数字分别取反</li>
</ul>
</li>
</ul>
</li>
<li>移码-》原码<ul>
<li>方法：移码转换为补码，再转换为原码</li>
</ul>
</li>
</ul>
</li>
<li><p>数据从补码和反码表示形式转换成原码</p>
<ul>
<li>自低位开始转换，从低位向高位，在遇到第一个1之前，保存各位的0不变，第一个1也不变，以后得各位按位取反，最后保持符号位不变，经历一遍后，即可得到补码</li>
</ul>
</li>
<li><p>定点数和浮点数</p>
<ul>
<li>定点数<ul>
<li>小数点固定在某个位置上的数据<ul>
<li>32位定点小数、定点整数补码的范围<ul>
<li>32位定点小数-1～1-2-31</li>
<li>32位定点整数-231～231-1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>浮点数<ul>
<li>根据IEEE754国际标准，常用的浮点数有两种格式<ul>
<li>Nmax=Mmax<em>2的Emax<br>Nmin=Mmin</em>2的Emax</li>
<li>单精度(32位)=8位阶码+24位尾数<ul>
<li>单精度浮点数(32位)，阶码8位(含一位符号位)，尾数24(含一位符号位)，取值范围:-2的127次方～(1-2的-23次方)*2的127次方</li>
</ul>
</li>
<li>双精度(64位)=11位阶码+53位尾数<ul>
<li>双精度浮点数(64位)，阶码11位(含一位符号位)，尾数53位(含一位符号位)，取值范围:-2的1023次方～(1-2的-52次方)*2的1023次方</li>
</ul>
</li>
</ul>
</li>
<li>为了保证数据精度，尾数通常用规格化形式表示:当R=2，且尾数值不为0时，其绝对值应大于或等于(0.5)10<ul>
<li>左规</li>
<li>右规</li>
</ul>
</li>
<li>小数点位置可以浮动的数据。</li>
<li>表示形式：N = M · RE</li>
<li>计算机中存储形式<ul>
<li>Ms+Es+E(n位)+M(m位)<ul>
<li>阶码E，一般为整数，用补码或者移码表示；</li>
<li>尾数M，一般为规格化的定点小数，用补码表示；<h3 id="二进制乘法运算"><a href="#二进制乘法运算" class="headerlink" title="二进制乘法运算"></a>二进制乘法运算</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>定点原码一位乘法</p>
<ul>
<li>两个原码数相乘，其乘积的符号为相乘两数符号的异或值，数值则为两数绝对值之积<ul>
<li>[X·Y]原=[X]原·[Y]原=(X0⊕Y0)|(X1X2..Xn) · (Y1Y2..Yn)</li>
</ul>
</li>
<li>几点结论<ul>
<li>从低到高根据乘数每位0、1决定相加被乘数还是0；</li>
<li>相加数每次左移，最后一起求积；</li>
<li>符号由异或决定</li>
</ul>
</li>
<li>表达式</li>
<li>电路框架</li>
<li>修正<ul>
<li>1.在机器内多个数据一般不能同时相加，一次加法操作只能求出两数之和，因此每每求得一个相加数，就与上次部分积相加</li>
<li>2.人工计算时，相加数逐次向左偏移一位，由于最后的乘积位数是乘数(或被乘数)的两倍，如按此算法在机器中运算，加法器也需增到两倍。观察计算过程很容易发现，在求本次部分积时，前一次部分积的最低位不再参与运算，因此可将其右移一位，相加数可直送而不必偏移，于是用N位加法器就可实现两个N位数相乘</li>
<li>部分积右移时，乘数寄存器同时右移一位，这样可以用乘数寄存器的最低位来控制相加数(取被乘数或零)，同时乘数寄存器的最高位可接受部分积右移出来的一位，因此，完成乘法运算后，A寄存器中保存乘积的高位部分，乘数寄存器中保存乘积低位部分</li>
</ul>
</li>
<li>例题</li>
<li>控制流程图</li>
</ul>
</li>
<li><p>定点补码一位乘法</p>
<ul>
<li>表达式</li>
<li>[X·Y]补=[X]补·(－Y0+Y1·2-1+….Yn·2-n)</li>
<li>注意：此处为双符号位，当最后乘积高位为负数时，需要补充加上[-|x|]补的操作<h3 id="二进制除法"><a href="#二进制除法" class="headerlink" title="二进制除法"></a>二进制除法</h3></li>
</ul>
</li>
<li><p>加减交替法</p>
<ul>
<li>当余数为正时，商上1，求下一位商的办法是，余数左移一位，再减去除数;当余数为负时，商上0，求下一位商的办法是，余数左移一位，再加上除数。此方法不用恢复余数，所以又叫不恢复余数法。但若最后一次上商为0而又需得到正确余数，则在这最后扔需恢复余数<h3 id="浮点数的运算方法"><a href="#浮点数的运算方法" class="headerlink" title="浮点数的运算方法"></a>浮点数的运算方法</h3></li>
</ul>
</li>
<li><p>浮点数的加减法运算</p>
<ul>
<li>1.对阶操作<ul>
<li>求出△E，再对小的进行移位</li>
</ul>
</li>
<li>2.尾数的加减运算</li>
<li>3.规格化操作<ul>
<li>规则简化是符号位和数值最高位不同，即00.1xxxx或11.0xxxx</li>
</ul>
</li>
<li>4.舍入<ul>
<li>超出表示范围的高位为1舍入</li>
</ul>
</li>
<li>5.检查阶码是否溢出</li>
</ul>
</li>
<li><p>浮点数的乘除法运算</p>
<ul>
<li>1.浮点数阶码运算(移码)<ul>
<li>牢记公式<ul>
<li>[X+Y]移=[X]移+[Y]补</li>
<li>[X–Y]移=[X]移+[–Y]补</li>
</ul>
</li>
</ul>
</li>
<li>2.按照一位乘或加减交替除运算<ul>
<li>先确定符号，在列式子计算<h3 id="运算部件"><a href="#运算部件" class="headerlink" title="运算部件"></a>运算部件</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>ABC寄存器作业</p>
</li>
<li><p>定点运算部件</p>
</li>
<li><p>浮点运算部件</p>
<ul>
<li>由阶码运算部件和尾数运算部件组成<h3 id="数据校验码"><a href="#数据校验码" class="headerlink" title="数据校验码"></a>数据校验码</h3></li>
</ul>
</li>
<li><p>码距</p>
<ul>
<li>任意两个合法码之间不相同的二进制位数的最小值<ul>
<li>要具有差错能力，则码距&gt;1</li>
<li>合理增大码距，就能提高发现错误的能力</li>
</ul>
</li>
</ul>
</li>
<li><p>鉴定方法</p>
<ul>
<li>有无差错能力</li>
<li>是否能合理增大码距</li>
</ul>
</li>
<li><p>奇偶校验码</p>
<ul>
<li>能发现数据代码中一位或奇数个位出错情况的编码</li>
<li>实现原理是使码距由1增加到2<ul>
<li>步骤1：在字节高位补充一位，即校验位</li>
<li>步骤2：依据图3.10电路形成原始数据D8..D1的校验位值</li>
<li>步骤3：将9位数据写入主存</li>
<li>步骤4：读出该数据时，读取数据D8..D1通过图3.10判定合法性</li>
</ul>
</li>
<li>电路图</li>
<li>结论<ul>
<li>（1）奇偶校验码只能发现一位或奇位错，且不能确定出错位置</li>
<li>（2）奇偶校验码的码距=2</li>
</ul>
</li>
</ul>
</li>
<li><p>海明校验码</p>
<ul>
<li>海明码位号和校验位位号的关系<ul>
<li>Pi的位置在2的i-1次方，但是除了最高位</li>
</ul>
</li>
<li>笔记<ul>
<li>3,5,7||3,6,7||5,6,7</li>
</ul>
</li>
<li>电路图</li>
<li>海明码码距为4</li>
<li>纠一位错，查一位错<ul>
<li>2∧r≥k+r+1</li>
</ul>
</li>
<li>纠一位错，查两位错<ul>
<li>2∧(r–1)≥k+r</li>
</ul>
</li>
</ul>
</li>
<li><p>循环冗余校验码(CRC)</p>
<ul>
<li>CRC码可以发现并纠正信息存储或传送过程中连续出现的多位错误</li>
<li>CRC码一般是指k位信息码之后拼接r位校验码</li>
<li>模2运算<ul>
<li>模2加减</li>
<li>模2乘除</li>
<li>异或逻辑</li>
</ul>
</li>
<li>CRC的译码与纠错<ul>
<li>更换不同的待测码字可以证明:余数与出错位的对应关系是不变，只与码制和生成多项式有关</li>
<li>图<h2 id="第四章-主存储器"><a href="#第四章-主存储器" class="headerlink" title="第四章 主存储器"></a>第四章 主存储器</h2><h3 id="主存储器处于全机中心低位"><a href="#主存储器处于全机中心低位" class="headerlink" title="主存储器处于全机中心低位"></a>主存储器处于全机中心低位</h3><h3 id="辅助存储器或称为外存储器，通常用来存放主存的副本和当前不在运行的程序和数据"><a href="#辅助存储器或称为外存储器，通常用来存放主存的副本和当前不在运行的程序和数据" class="headerlink" title="辅助存储器或称为外存储器，通常用来存放主存的副本和当前不在运行的程序和数据"></a>辅助存储器或称为外存储器，通常用来存放主存的副本和当前不在运行的程序和数据</h3><h3 id="主存储器的类型"><a href="#主存储器的类型" class="headerlink" title="主存储器的类型"></a>主存储器的类型</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>随机存储器RAM</p>
</li>
<li><p>非易失性存储器</p>
<h3 id="主存储器的主要技术指标"><a href="#主存储器的主要技术指标" class="headerlink" title="主存储器的主要技术指标"></a>主存储器的主要技术指标</h3></li>
<li><p>主存容量</p>
<ul>
<li>64×8等等</li>
<li>计算机可寻址的最小信息单元是一个存储字</li>
<li>主存储器存储单元的总数</li>
</ul>
</li>
<li><p>存取速度</p>
<ul>
<li>由存储器存取时间和存储周期表示</li>
</ul>
</li>
<li><p>存储器存取时间</p>
<ul>
<li>启动一次存储器操作(读/写)到完成该操作所经历的时间</li>
</ul>
</li>
<li><p>存储周期</p>
<ul>
<li>连续启动两次独立的存储器操作所间隔的最小时间<h3 id="主存储器的基本操作"><a href="#主存储器的基本操作" class="headerlink" title="主存储器的基本操作"></a>主存储器的基本操作</h3></li>
</ul>
</li>
<li><p>CPU通过使用AR(地址寄存器)和DR(数据寄存器)和主存进行数据传送</p>
</li>
<li><p>若AR为K位字长，DR为n位字长，则允许主存包含2∧k个可寻址单元</p>
</li>
<li><p>CPU与主存采取异步工作方式，以ready信号表示一次访存操作的结束</p>
<h3 id="读-写存储器"><a href="#读-写存储器" class="headerlink" title="读/写存储器"></a>读/写存储器</h3></li>
<li><p>随机存储器(RAM)按存储元件在运行中能否长时间保存信息分为静态存储器和动态存储器</p>
</li>
<li><p>静态存储器，利用触发器保存信息，只要不断电，信息就不会丢失</p>
<ul>
<li>电路简图</li>
<li>MOS静态存储结构图</li>
</ul>
</li>
<li><p>动态存储器，利用MOS电容存储电荷来保存信息，需要不断给电容充电才能使信息来保存信息</p>
<ul>
<li>电路简图</li>
<li>16K×1位动态存储器框图</li>
<li>再生<ul>
<li>集中式</li>
<li>分散式</li>
<li>时间小于或等于2ms</li>
<li>行读出再生<h3 id="非易失性半导体存储器"><a href="#非易失性半导体存储器" class="headerlink" title="非易失性半导体存储器"></a>非易失性半导体存储器</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>只读存储器ROM</p>
<ul>
<li>只读不能写</li>
</ul>
</li>
<li><p>可编程序的只读存储器PROM</p>
<ul>
<li>一次性写入</li>
</ul>
</li>
<li><p>可擦可编程序的只读存储器EPROM</p>
<ul>
<li>可多次写入、读出</li>
</ul>
</li>
<li><p>可电擦可编程序只读存储器E2PROM</p>
<ul>
<li>可多次读出但写入次数有限</li>
</ul>
</li>
<li><p>快擦除读写存储器Flash Memory</p>
<ul>
<li>重复写入、读出<h3 id="存储器的组成与控制"><a href="#存储器的组成与控制" class="headerlink" title="存储器的组成与控制"></a>存储器的组成与控制</h3></li>
</ul>
</li>
<li><p>存储器容量扩展</p>
<ul>
<li>位扩展:用多个存储器芯片对字长进行扩充</li>
<li>字扩展:增加存储器中字的数量，提高存储器的寻址范围</li>
<li>字位扩展，假设一个存储器的容量为M×N位，若使用L×K位存储器芯片，那么，这个存储器共需要(M/L)×(N/K)个存储器芯片<h3 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h3></li>
</ul>
</li>
<li><p>提高访存速度的方式</p>
<ul>
<li>采用高速器件</li>
<li>采用层次结构</li>
<li>调整主存结构</li>
</ul>
</li>
<li><p>计算机中大容量的主存可由多个存储体组成，每个存储体都具有自己的读写线路，地址寄存器和数据寄存器，称为”存储模块”。这种多模块存储器可以实现重叠与交叉存取</p>
</li>
<li><p>第i个模块M的地址编号应按下式给出:M×j+i</p>
</li>
<li><p>连续地址分布在相邻的不同模块内，而同一模块内的地址都是不连续的</p>
<h2 id="第五章-指令系统"><a href="#第五章-指令系统" class="headerlink" title="第五章:指令系统"></a>第五章:指令系统</h2><h3 id="指令系统的发展"><a href="#指令系统的发展" class="headerlink" title="指令系统的发展"></a>指令系统的发展</h3></li>
<li><p>20世纪70年代末人们提出了便于VLSI实现的精简指令系统计算机，简称RISC，同时将指令系统越来越复杂的计算机称为复杂指令系统计算机，简称CISC</p>
<h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3></li>
<li><p>结构(操作码+地址码)</p>
<ul>
<li>操作码</li>
<li>操作数的地址</li>
<li>操作结果的存储地址</li>
<li>下一条指令的地址</li>
</ul>
</li>
<li><p>地址码</p>
<ul>
<li>零地址指令</li>
<li>一地址指令<ul>
<li>寻址范围  224 = 16 M<ul>
<li>2次访存</li>
</ul>
</li>
</ul>
</li>
<li>二地址指令<ul>
<li>寻址范围  212 = 4 K<ul>
<li>4 次访存</li>
</ul>
</li>
</ul>
</li>
<li>三地址指令<ul>
<li>寻址范围  28 = 256<ul>
<li>4 次访存</li>
</ul>
</li>
</ul>
</li>
<li>多地址指令<ul>
<li>寻址范围  26 = 64<ul>
<li>4 次访存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>指令字长</p>
<ul>
<li>取决因素<ul>
<li>操作码的长度</li>
<li>操作数地址的长度</li>
<li>操作数地址的个数</li>
</ul>
</li>
<li>指令字长 固定<ul>
<li>指令字长 = 存储字长</li>
</ul>
</li>
<li>指令字长 可变<ul>
<li>按字节的倍数变化</li>
</ul>
</li>
<li>对准边界存放<ul>
<li>不连续存放数据</li>
<li>按字节编址<ul>
<li>a.半字地址最低位恒为0</li>
<li>b.字地址最低两位恒为0</li>
<li>c.双字地址的最低三位恒为0</li>
</ul>
</li>
<li>减少访存次数，浪费存储空间</li>
</ul>
</li>
<li>不 对 准 边 界 存 放<ul>
<li>连续存放数据</li>
<li>节约存储器空间，但增加访存次数，对多字节数据存在调整高 低字节位置的问题</li>
</ul>
</li>
</ul>
</li>
<li><p>寻址方式</p>
<ul>
<li>确定本条指令的数据地址</li>
<li>下一条要执行的指令地址的方法</li>
</ul>
</li>
<li><p>指令操作码的扩展技术</p>
<ul>
<li>指令操作码的长度决定了指令系统中完成不同操作的指令数</li>
<li>若某机器的操作码长度固定为K位，则它最多只能有2^K条不同指令</li>
<li>指令操作码两种格式<ul>
<li>固定格式<ul>
<li>优点:对于简化硬件设计，减少指令译码时间非常有利</li>
<li>缺点:指令少，浪费地址</li>
</ul>
</li>
<li>可变格式(分散地放在字的不同字段)<ul>
<li>优点:指令多，缩短指令平均长度，减少程序总位数，增加指令字所能表示的操作信息</li>
<li>缺点:译码复杂，控制器的设计难度增大</li>
</ul>
</li>
</ul>
</li>
<li>拓展方法的一个重要原则<ul>
<li>使用频度(即指令在程序中出现概率)高的指令应分配短的操作码，使用频度低的指令相应地分配较长的操作码</li>
</ul>
</li>
</ul>
</li>
<li><p>指令系统的兼容性</p>
<ul>
<li>保持系统向上兼容<h3 id="精简指令系统计算机（RISC）——用于小型机"><a href="#精简指令系统计算机（RISC）——用于小型机" class="headerlink" title="精简指令系统计算机（RISC）——用于小型机"></a>精简指令系统计算机（RISC）——用于小型机</h3><h3 id="复杂指令系统计算机（CISC）——用于大型机"><a href="#复杂指令系统计算机（CISC）——用于大型机" class="headerlink" title="复杂指令系统计算机（CISC）——用于大型机"></a>复杂指令系统计算机（CISC）——用于大型机</h3><h2 id="第六章：中央处理器"><a href="#第六章：中央处理器" class="headerlink" title="第六章：中央处理器"></a>第六章：中央处理器</h2><h3 id="计算机工作过程"><a href="#计算机工作过程" class="headerlink" title="计算机工作过程"></a>计算机工作过程</h3></li>
</ul>
</li>
<li><p>加电——》产生reset信号——》执行程序——》停机——》停电</p>
</li>
<li><p>产生reset信号的任务</p>
<ul>
<li>任务一：使计算机处于初始状态</li>
<li>任务二：从PC中取出指令地址</li>
</ul>
</li>
<li><p>控制器作用是协调并控制计算机各部件执行程序的指令序列</p>
<h3 id="控制器的组成"><a href="#控制器的组成" class="headerlink" title="控制器的组成"></a>控制器的组成</h3></li>
<li><p>控制器的功能</p>
<ul>
<li>取指令<ul>
<li>发出指令地址，取出指令的内容</li>
</ul>
</li>
<li>分析指令<ul>
<li>（1）对操作码译码产生操作相应部件的控制信号</li>
<li>（2）根据寻址方式形成操作数地址</li>
</ul>
</li>
<li>执行指令<ul>
<li>（1）根据分析指令后产生控制信号、操作数地址信号序列，通过CPU及输入输出设备的执行实现每条指令的功能</li>
<li>（2）结果回送存储器</li>
<li>（3）形成下条指令的地址</li>
</ul>
</li>
<li>控制程序和数据的输入和结果输出</li>
<li>对异常情况和某些请求的处理<ul>
<li>异常情况的处理：例如算术运算的溢出、数据传送奇偶错</li>
<li>某些请求的处理<ul>
<li>“中断请求”信号</li>
<li>DMA请求信号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>控制器的组成</p>
<ul>
<li>程序计数器（PC）<ul>
<li>即地址寄存器，用来存放当前正在执行的指令地址或即将要执行的下一条指令地址</li>
</ul>
</li>
<li>指令寄存器（IR）<ul>
<li>用以存放当前正在执行的指令，以便在指令执行过程中控制完成一条指令的全部功能</li>
</ul>
</li>
<li>指令译码器或操作码译码器<ul>
<li>对指令寄存器中的操作码进行分析解释，产生相应的控制信号</li>
</ul>
</li>
<li>脉冲源及启停线路<ul>
<li>脉冲源参数一定评率的脉冲作为整个机器的时钟脉冲，是机器周期和工作脉冲的基准信号，在机器刚加电时，还应产生一个总清信号（reset）</li>
</ul>
</li>
<li>时序控制信号形成部件<ul>
<li>当程序启动后，在CLK时钟作用下，根据当前正在执行的指令的需要，产生相应的时序控制信号，并根据被控制功能部件的反馈信号调整时序控制信号<ul>
<li>控制存储器</li>
<li>微指令寄存器<ul>
<li>控制字段+下址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>周期概念<ul>
<li>指令周期<ul>
<li>完成一条指令所需的时间，包括取指令、分析指令、执行指令</li>
</ul>
</li>
<li>机器周期<ul>
<li>也称为CPU周期，是CPU从内存中读取一个指令的时间，通常等于取指周期</li>
</ul>
</li>
<li>时钟周期<ul>
<li>称为节拍脉冲或T周期，是基准脉冲信号</li>
</ul>
</li>
</ul>
</li>
<li>三条假设<ul>
<li>程序是存放在主存中的，当执行完一条指令后才从主存中取下一条指令（非流水线）</li>
<li>指令的长度是固定的，并限制了寻址方式的多样化</li>
<li>在程序运行前，程序和数据都已存在主存中</li>
</ul>
</li>
</ul>
</li>
<li><p>指令执行过程（运算器和控制器配合）</p>
<ul>
<li>组成控制器的基本电路<ul>
<li>具有记忆功能的触发器以及由它组成的寄存器，计数器和存储单元</li>
<li>没有记忆功能的门电路及由它组成的加法器，算术逻辑运算单元（ALU）和各种逻辑电路</li>
</ul>
</li>
<li>举例<ul>
<li>加法<ul>
<li>取指令——》计算操作数地址——》取操作数——》执行结果并运算送结果</li>
</ul>
</li>
<li>要能看懂时序图<ul>
<li>哪些指令在对应的时间有效</li>
</ul>
</li>
<li>条件转移指令<ul>
<li>取指令——》计算地址</li>
</ul>
</li>
</ul>
</li>
<li>控制器的功能就是按每一条指令的要求产生所需的控制信号</li>
<li>产生控制信号的方法<ul>
<li>微程序控制</li>
<li>硬布线控制<h3 id="微程序控制计算机的基本工作原理"><a href="#微程序控制计算机的基本工作原理" class="headerlink" title="微程序控制计算机的基本工作原理"></a>微程序控制计算机的基本工作原理</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>基本概念</p>
<ul>
<li>微指令<ul>
<li>在微程序控制的计算机中，将由同时发出的控制信号所执行的一组微操作</li>
</ul>
</li>
<li>微命令<ul>
<li>将指令分为若干条微指令，按次序执行这些微指令。组成微指令的操作即微命令</li>
</ul>
</li>
<li>微程序<ul>
<li>计算机的程序由指令序列构成，而计算机每条指令的功能均由微指令序列解释完成，这些微指令序列的集合就叫做微程序</li>
</ul>
</li>
<li>控制存储器<ul>
<li>微程序一般是存放在专门的存储器中的，由于该存储器主要存放控制命令（信号）与下一条执行的微指令地址（简称下址）</li>
<li>存储单元内容<ul>
<li>（1）微指令的控制信号——控制位</li>
<li>（2）下条微指令的地址——下址字段</li>
</ul>
</li>
<li>存储芯片：ROM</li>
</ul>
</li>
<li>执行一条指令实际上就是执行一段存放在控制存储器中的微程序</li>
</ul>
</li>
<li><p>实现微程序控制的基本原理</p>
<ul>
<li>控制信号（23条）</li>
<li>书上P123页为加法的过程</li>
<li>微指令格式：控制字段+下址字段</li>
<li>23个控制位，12个下址位——》容量为4K</li>
<li>取址微指令的操作对所有指令都是相同的，所以是一条公用的微指令，其下址由操作码译码产生</li>
</ul>
</li>
<li><p>微程序控制器</p>
</li>
<li><p>时序信号及工作脉冲的形成</p>
</li>
<li><p>停机和停电的区别</p>
<ul>
<li>停机<ul>
<li>电压：稳定<ul>
<li>存放内容：保持<ul>
<li>重启PC内容：断点指令地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>停电<ul>
<li>电压：消失<ul>
<li>存放内容：RAM的内容消失<ul>
<li>重启PC内容：第一条指令地址<h3 id="微程序设计技术"><a href="#微程序设计技术" class="headerlink" title="微程序设计技术"></a>微程序设计技术</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如何缩短微指令字长</p>
<ul>
<li>直接控制法（容量太小）<ul>
<li>编译方法：每一位代表一个控制信号，直接送往相应的控制点</li>
<li>优点：控制简单</li>
<li>缺点：微指令字长过大</li>
</ul>
</li>
<li>字段直接编译法<ul>
<li>选出互斥的微指令</li>
<li>每个字段都要留出一个代码，表示本段不发出任何指令（000）</li>
<li>优点：节省微指令的字长</li>
<li>缺点：增加了额外的硬件开销</li>
</ul>
</li>
<li>字段间接编译法<ul>
<li>指令之间相互联系的情况</li>
<li>举例：A为0-7，B为0-3，如果是直接编译——3+2=5，如果是间接编译——3+1=4</li>
<li>编码方法：在字段直接编译法中，译码输出端要兼由另一字段中的某些微命令配合解释</li>
<li>优点：减少了微指令长度</li>
<li>缺点：可能削弱微指令的并行控制能力，同时增加硬件开销</li>
</ul>
</li>
<li>常熟源字段E(了解)</li>
</ul>
</li>
<li><p>如何减少微指令长度</p>
<ul>
<li>现行微指令/微地址<ul>
<li>现行微指令：当前正在执行的指令</li>
<li>现行微地址：存放现行微指令的控制器存储单元</li>
</ul>
</li>
<li>后继微指令/微地址<ul>
<li>后继微指令：下一条要执行的微指令</li>
<li>后继微地址：存放后继微指令的控制器存储单元</li>
</ul>
</li>
<li>增量与下址字段结合产生后继微指令的方法<ul>
<li>下址字段分成：转移控制字段BCF和转移地址字段BAF<ul>
<li>BCF：控制微程序的转移情况</li>
<li>BAF：转移后的微指令所在地址</li>
</ul>
</li>
<li>BAF有两种情况<ul>
<li>与uPC的位数相等——转移灵活，但增加微指令长度</li>
<li>比uPC短——转移地址收到限制，但可缩短微指令长度</li>
</ul>
</li>
<li>优点<ul>
<li>微指令的下址字段很短，仅用于选择输入uPC计数器的某条线路有效</li>
</ul>
</li>
<li>缺点<ul>
<li>微程序转移不灵活，使得微程序在控存中的物理空间分配有困难</li>
</ul>
</li>
</ul>
</li>
<li>多路转移方式<ul>
<li>一条微指令存在多个转移分支的情况称为多路转移</li>
</ul>
</li>
<li>微中断<ul>
<li>1.微中断请求信号是由程序中断请求信号引起的</li>
<li>2.在完成现行指令的微程序后响应该微中断请求</li>
<li>3.由硬件产生对应微中断处理程序在控存中的入口地址</li>
</ul>
</li>
</ul>
</li>
<li><p>如何提高微程序的执行速度</p>
</li>
<li><p>微指令格式</p>
<ul>
<li>水平型微指令——直接控制，字段编译（直接、间接）<ul>
<li>特点：在一条微指令中定义并并行执行多个微命令</li>
</ul>
</li>
<li>垂直型微指令<ul>
<li>特点：不强调实现微指令的并行控制功能</li>
<li>定义：采用微操作码编译法，由操作码规定微指令的功能</li>
</ul>
</li>
</ul>
</li>
<li><p>微程序控制存储器</p>
<ul>
<li>一般采用ROM存储器</li>
<li>也可采用RAM，为防止断电后内容消失，则必须开机后将外存中存放的微程序调入控存RAM，然后才能执行程序。</li>
<li>当前为了能不断扩展指令系统，通常采用ROM+RAM</li>
</ul>
</li>
<li><p>动态微程序设计</p>
<ul>
<li>定义：能根据用户要求改变微程序</li>
<li>优点：是计算机能更灵活、有效的适应于各种不同的应用目标</li>
</ul>
</li>
<li><p>控制存储器的操作（P136）</p>
<ul>
<li>串行方式</li>
<li>并行方式——比串行多了微指令寄存器<ul>
<li>微周期=max(取微指令时间,执行微指令时间)</li>
<li>由于取微指令、执行微指令同时进行，故对于某些后继微地址的产生根据处理结果而定的微指令，则延迟一个微周期再取微指令<h3 id="硬布线控制的计算机（RISC）——特点快"><a href="#硬布线控制的计算机（RISC）——特点快" class="headerlink" title="硬布线控制的计算机（RISC）——特点快"></a>硬布线控制的计算机（RISC）——特点快</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>形成操作控制信号的逻辑框图（P141）</p>
</li>
<li><p>操作控制信号的产生</p>
<ul>
<li>取值周期cy1所产生的信号对所有指令都是相同的，即与当前执行的指令无关，逻辑式得到最简单的形式</li>
<li>通常，同一个控制控制信号在若干条指令的某些周期（或再加上一些条件）中都需要，为此需要把它们组合起来</li>
<li>同种类型的指令所需要的控制信号大部分是相同的，仅有少量区别</li>
<li>在确定指令的操作码时（即对具体指令赋予二进制操作码），为了便于逻辑表达式的化简以减少逻辑电路数量，往往给予特别关注</li>
</ul>
</li>
<li><p>设计组合逻辑电路从而产生需要的控制信号的步骤</p>
<ul>
<li>1.实际逻辑问题2.真值表3.公式化简4.逻辑电路图</li>
</ul>
</li>
<li><p>设计目标</p>
<ul>
<li>使用最少的电路元件达到最高的操作速度<h3 id="流水线工作原理"><a href="#流水线工作原理" class="headerlink" title="流水线工作原理"></a>流水线工作原理</h3></li>
</ul>
</li>
<li><p>几点结论</p>
<ul>
<li>每条指令的执行时间不变</li>
<li>每条指令处理结果的时间缩短</li>
<li>流水线处理速率最高时=流水线处于满载的稳定状态</li>
<li>流水线处理速率最低时=流水线未满载状态</li>
<li>为了满足在重叠时间段不同指令的机器周期能够完成指定的操作，将时间段=操作完成的最长时间</li>
<li>为了保证一个周期内流水线的输入信号不变，相邻时间段之间必须设置锁存器或寄存器</li>
<li>除了指令执行流水线，还有运算操作流水线</li>
</ul>
</li>
<li><p>相关问题</p>
<ul>
<li>流水线阻塞（P163-6.15）<ul>
<li>数据相关产生<ul>
<li>假设第二条指令需要的操作数是第一条指令运算的结果，那么出现了数据相关</li>
</ul>
</li>
<li>指令执行时间不同产生</li>
<li>程序转移的影响</li>
<li>异常情况响应中断<h2 id="第七章：存储系统"><a href="#第七章：存储系统" class="headerlink" title="第七章：存储系统"></a>第七章：存储系统</h2><h3 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>cache-&gt;主存-&gt;辅存</p>
<h3 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h3></li>
<li><p>cache的工作原理</p>
<ul>
<li>局部性原理</li>
<li>主存地址和cache地址（P166 图7.2）</li>
<li>块长<ul>
<li>块长一般取一个主存周期所能调出的信息长度（一般为16个字）</li>
</ul>
</li>
<li>cache的容量和块的大小是影响cache的效率的重要因素</li>
<li>命中率<ul>
<li>CPU所要访问的信息是否在cache中的比率，而将所要访问的信息不在cache中的比率称为失败率</li>
</ul>
</li>
<li>一致性策略<ul>
<li>标志交换方式（写回法）</li>
<li>通过式写入（写通法）</li>
<li>写操作直接对主存进行，而不写入cache</li>
</ul>
</li>
<li>cache的存取时间<ul>
<li>平均存取时间=h*tc+(1-h)(tc+tm) </li>
</ul>
</li>
<li>最好替换策略<ul>
<li>按照被替换的字块是下一段时间最少使用的，由替换部件实现</li>
</ul>
</li>
</ul>
</li>
<li><p>cache组织</p>
<ul>
<li>地址映像<ul>
<li>直接映像<ul>
<li>cache中许多空的位置被浪费</li>
<li>主存地址：主存字块标记+cache字块地址+字块内地址</li>
</ul>
</li>
<li>全相联映像<ul>
<li>成本太高而不能采用</li>
<li>主存地址：主存字块标记+字块内地址</li>
<li>优点<ul>
<li>方式灵活，缩小了块发生冲突的概率</li>
</ul>
</li>
<li>缺点<ul>
<li>增加了标识位位数</li>
<li>增加了寻找主存块在cache中对应块的时间</li>
</ul>
</li>
</ul>
</li>
<li>组相联映像<ul>
<li>直接映像和全相联映像的折衷</li>
<li>主存地址：主存字块标记+组地址+块内地址<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>存储管理部件（MMU）</p>
<ul>
<li>现代计算机一般都有辅助存储器，但具有辅存的存储系统不一定是虚拟存储系统</li>
<li>虚拟存储系统的特点<ul>
<li>允许用户程序用比主存大的多的空间来访问主存</li>
<li>每次访存都要进行虚实地址的转换<h2 id="第八章：辅助存储器"><a href="#第八章：辅助存储器" class="headerlink" title="第八章：辅助存储器"></a>第八章：辅助存储器</h2><h3 id="半导体存储器可随机访问任一单元，而辅助存储器一般为串行访问存储器"><a href="#半导体存储器可随机访问任一单元，而辅助存储器一般为串行访问存储器" class="headerlink" title="半导体存储器可随机访问任一单元，而辅助存储器一般为串行访问存储器"></a>半导体存储器可随机访问任一单元，而辅助存储器一般为串行访问存储器</h3><h3 id="辅助存储器的种类"><a href="#辅助存储器的种类" class="headerlink" title="辅助存储器的种类"></a>辅助存储器的种类</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>磁表面存储器</p>
<ul>
<li>数字式磁记录<ul>
<li>硬盘、软盘和磁带</li>
</ul>
</li>
<li>模拟式磁记录<ul>
<li>录音、录像设备</li>
</ul>
</li>
</ul>
</li>
<li><p>光存储器</p>
<ul>
<li>光盘<h3 id="串行存储器"><a href="#串行存储器" class="headerlink" title="串行存储器"></a>串行存储器</h3></li>
</ul>
</li>
<li><p>顺序存取存储器</p>
</li>
<li><p>直接存取存储器</p>
<h3 id="辅助存储器的技术指标"><a href="#辅助存储器的技术指标" class="headerlink" title="辅助存储器的技术指标"></a>辅助存储器的技术指标</h3></li>
<li><p>存储密度</p>
<ul>
<li>定义：单位长度或单位面积磁层表面磁层所存储的二进制信息量</li>
<li>道密度<ul>
<li>沿磁盘半径方向单位长度的磁道数称为道密度，单位为道/英寸tpi或道/毫米tpmm</li>
</ul>
</li>
<li>位密度或线密度<ul>
<li>单位长度磁道所能记录二进制信息的位数叫位密度或线密度，单位为位/英寸bpi或位/毫米bpmm</li>
</ul>
</li>
<li>每个磁道所存储的信息量是一样的</li>
</ul>
</li>
<li><p>存储容量</p>
<ul>
<li>C = n × k × s</li>
</ul>
</li>
<li><p>寻址时间</p>
<ul>
<li>平均寻址时间Ta=平均找道时间Ts+平均等待时间Tw</li>
<li>辅存的速度<ul>
<li>寻址时间</li>
<li>磁头读写时间</li>
</ul>
</li>
</ul>
</li>
<li><p>数据传输率</p>
<ul>
<li>Dr  = D × V</li>
</ul>
</li>
<li><p>误码率</p>
</li>
<li><p>价格</p>
<h3 id="硬磁盘存储器的类型"><a href="#硬磁盘存储器的类型" class="headerlink" title="硬磁盘存储器的类型"></a>硬磁盘存储器的类型</h3></li>
<li><p>(1) 固定磁头和移动磁头</p>
</li>
<li><p>(2) 可换盘和固定盘</p>
<h3 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h3></li>
<li><p>温彻斯特磁盘简称温盘</p>
</li>
<li><p>磁盘存储器由驱动器（HDD），控制器（HDC）和盘片组成</p>
</li>
<li><p>最外面的同心圆叫0磁道，最里面的同心圆假设称为n磁道</p>
</li>
<li><p>驱动器的定位驱动系统实现快速精准的磁头定位</p>
</li>
<li><p>主轴系统的作用是带动盘片按额定转速稳定旋转</p>
</li>
<li><p>数据控制系统的作用是控制数据的写入和读出，包括寻址，磁头旋转，写电流控制，读出放大，数据分离</p>
</li>
<li><p>磁盘控制器有两个方向的接口</p>
<ul>
<li>与主机的接口</li>
<li>与驱动器（设备）的接口<h3 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h3></li>
</ul>
</li>
<li><p>采用光存储技术</p>
<ul>
<li>利用激光写入和读出</li>
<li>第一代光存储技术<ul>
<li>采用非磁性介质<ul>
<li>不可擦写</li>
</ul>
</li>
</ul>
</li>
<li>第二代光存储技术<ul>
<li>采用磁性介质<ul>
<li>可擦写</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>光盘的存储原理</p>
<ul>
<li>只读型和只写一次型<ul>
<li>热作用（物理或化学变化）</li>
</ul>
</li>
<li>可擦写光盘<ul>
<li>热磁效应<h2 id="第九-十章：输出输出（I-O）设备-系统"><a href="#第九-十章：输出输出（I-O）设备-系统" class="headerlink" title="第九/十章：输出输出（I/O）设备/系统"></a>第九/十章：输出输出（I/O）设备/系统</h2><h3 id="设备控制器（I-O）的基本功能"><a href="#设备控制器（I-O）的基本功能" class="headerlink" title="设备控制器（I/O）的基本功能"></a>设备控制器（I/O）的基本功能</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>实现主机和外部设备之间的数据传送</p>
</li>
<li><p>实现数据缓冲，以达到主机同外部设备之间的速度匹配</p>
</li>
<li><p>接受主机的命令，提供设备接口的设备，并按照主机的命令控制设备</p>
<h3 id="I-O-编址方式"><a href="#I-O-编址方式" class="headerlink" title="I/O 编址方式"></a>I/O 编址方式</h3></li>
<li><p>(1) 统一编址：用取数、存数指令</p>
</li>
<li><p>(2) 不统一编址：有专门的 I/O 指令</p>
<h3 id="I-O-与主机的连接方式"><a href="#I-O-与主机的连接方式" class="headerlink" title="I/O 与主机的连接方式"></a>I/O 与主机的连接方式</h3></li>
<li><p>辐射式连接</p>
<ul>
<li>每台设备都配有一套</li>
<li>控制线路和一组信号线</li>
<li>不便于增删设备</li>
</ul>
</li>
<li><p>总线连接</p>
<ul>
<li>便于增删设备<h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3></li>
</ul>
</li>
<li><p>人机交互设备</p>
<ul>
<li>键盘、鼠标等</li>
</ul>
</li>
<li><p>计算机信息的驻留设备</p>
<ul>
<li>硬盘、光盘等</li>
</ul>
</li>
<li><p>机——机通信设备</p>
<ul>
<li>MODEN等<h3 id="为什么要设置接口？"><a href="#为什么要设置接口？" class="headerlink" title="为什么要设置接口？"></a>为什么要设置接口？</h3></li>
</ul>
</li>
<li><ol>
<li>实现设备的选择</li>
</ol>
</li>
<li><ol start="2">
<li>实现数据缓冲达到速度匹配</li>
</ol>
</li>
<li><ol start="3">
<li>实现数据串     并格式转换</li>
</ol>
</li>
<li><ol start="4">
<li>实现电平转换</li>
</ol>
</li>
<li><ol start="5">
<li>传送控制命令</li>
</ol>
</li>
<li><ol start="6">
<li>反映设备的状态<ul>
<li>（“忙”、“就绪”、“中断请求”）<h3 id="中断服务程序的流程"><a href="#中断服务程序的流程" class="headerlink" title="中断服务程序的流程"></a>中断服务程序的流程</h3></li>
</ul>
</li>
</ol>
</li>
<li><p>(1) 保护现场</p>
<ul>
<li>程序断点的保护</li>
<li>寄存器内容的保护</li>
</ul>
</li>
<li><p>(2) 中断服务</p>
<ul>
<li>对不同的 I/O 设备具有不同内容的设备服务</li>
</ul>
</li>
<li><p>(3) 恢复现场</p>
<ul>
<li>出栈指令</li>
</ul>
</li>
<li><p>(4) 中断返回</p>
<ul>
<li>中断返回指令<h3 id="单重中断和多重中断"><a href="#单重中断和多重中断" class="headerlink" title="单重中断和多重中断"></a>单重中断和多重中断</h3></li>
</ul>
</li>
<li><p>单重 中断</p>
<ul>
<li>不允许中断 现行的 中断服务程序</li>
</ul>
</li>
<li><p>多重 中断</p>
<ul>
<li>允许级别更高 的中断源</li>
<li>中断 现行的 中断服务程序<h3 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h3></li>
</ul>
</li>
<li><p>主存和 I/O 之间有一条直接数据通道</p>
</li>
<li><p>CPU 和 I/O 并行工作</p>
</li>
<li><p>DMA 的三种工作方式</p>
<ul>
<li>(1) CPU暂停方式</li>
<li>(2) CPU周期窃取方式</li>
<li>(3)直接访问存储器</li>
</ul>
</li>
<li><p>DMA 接口功能</p>
<ul>
<li>(1) 向 CPU 申请 DMA 传送</li>
<li>(2) 处理总线 控制权的转交</li>
<li>(3) 管理 系统总线、控制 数据传送</li>
<li>(4) 确定 数据传送的 首地址和长度，修正 传送过程中的数据地址和长度</li>
<li>(5) DMA 传送结束时，给出操作完成信号</li>
</ul>
</li>
<li><p>DMA 传送过程</p>
<ul>
<li>预处理、数据传送、后处理<h3 id="外设接口"><a href="#外设接口" class="headerlink" title="外设接口"></a>外设接口</h3></li>
</ul>
</li>
<li><p>设备与主机相连时，必须按照规定的物理互连特性、电气特性等进行连接，这些特性的技术规范称为接口标准</p>
</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180620085759852?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="计算机组成原理思维导图图片"></p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="http://yoursite.com/2019/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" data-id="ck3lclaai0003qkuy0a6g5zn7" class="article-share-link">Share</a>-->
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机操作系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">计算机操作系统</a>
    </h1>
  

        <a href="/2019/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2019-11-30T09:02:21.250Z" itemprop="datePublished">2019-11-30</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><h2 id="一-操作系统引论"><a href="#一-操作系统引论" class="headerlink" title="一.操作系统引论"></a>一.操作系统引论</h2><h3 id="1-操作系统的目标和功能"><a href="#1-操作系统的目标和功能" class="headerlink" title="1.操作系统的目标和功能"></a>1.操作系统的目标和功能</h3><ul>
<li><p>目标</p>
<ul>
<li>方便性</li>
<li>有效性<ul>
<li>提高系统资源利用率</li>
<li>提高系统吞吐量</li>
</ul>
</li>
<li>可扩充性</li>
<li>开放性</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>OS作为用户与计算机硬件系统之间的接口<ul>
<li>命令方式</li>
<li>系统调用方式</li>
<li>图标–窗口方式</li>
</ul>
</li>
<li>OS实现了对计算机资源的抽象<h3 id="2-操作系统的发展过程"><a href="#2-操作系统的发展过程" class="headerlink" title="2.操作系统的发展过程"></a>2.操作系统的发展过程</h3></li>
</ul>
</li>
<li><p>未配置操作系统的计算机系统</p>
<ul>
<li><p>人工操作方式</p>
<ul>
<li><blockquote>
<p>用户独占全机 CPU等待人工操作 严重降低了计算机资源的利用率</p>
</blockquote>
</li>
</ul>
</li>
<li><p>脱机输入/输出(Off–Line I/O)方式</p>
<ul>
<li><blockquote>
<p>减少了CPU的空闲时间 提高了I/O速度 效率仍然不理想</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单道批处理系统</p>
</li>
<li><p>多道批处理系统</p>
</li>
<li><blockquote>
<p>1.资源利用率高</p>
</blockquote>
</li>
<li><blockquote>
<p>2.系统吞吐量大</p>
</blockquote>
</li>
<li><blockquote>
<p>3.平均周转时间长</p>
</blockquote>
</li>
<li><blockquote>
<p>4.无交互能力</p>
</blockquote>
<ul>
<li>(宏观并行，微观串行)</li>
</ul>
</li>
<li><p>分时系统</p>
</li>
<li><blockquote>
<p>特征:</p>
</blockquote>
</li>
<li><blockquote>
<p>1.多路性</p>
</blockquote>
</li>
<li><blockquote>
<p>2.独立性</p>
</blockquote>
</li>
<li><blockquote>
<p>3.及时性</p>
</blockquote>
</li>
<li><blockquote>
<p>4.交互性</p>
</blockquote>
</li>
<li><p>实时系统</p>
</li>
<li><p>集群系统–超算~云计算</p>
</li>
<li><p>微机操作系统的发展</p>
<h3 id="3-操作系统的基本特征"><a href="#3-操作系统的基本特征" class="headerlink" title="3.操作系统的基本特征"></a>3.操作系统的基本特征</h3></li>
<li><p>1.并发concurrence</p>
<ul>
<li><p>区别并行和并发</p>
<ul>
<li><blockquote>
<p>并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行</p>
</blockquote>
</li>
<li><blockquote>
<p>并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行</p>
</blockquote>
<ul>
<li>并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行</li>
</ul>
</li>
</ul>
</li>
<li><p>引入进程</p>
<ul>
<li><blockquote>
<p>进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.共享sharing</p>
<ul>
<li>1.互斥共享方式</li>
<li>2.同时访问方式</li>
<li>并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件</li>
</ul>
</li>
<li><p>3.虚拟virtual</p>
<ul>
<li>时分复用技术</li>
<li>空分复用技术</li>
</ul>
</li>
<li><p>4.异步asynchronism</p>
<h3 id="4-操作系统的主要功能"><a href="#4-操作系统的主要功能" class="headerlink" title="4.操作系统的主要功能"></a>4.操作系统的主要功能</h3></li>
<li><p>1.处理机管理功能</p>
<ul>
<li>进程控制</li>
<li>进程同步<ul>
<li>进程互斥方式</li>
<li>进程同步方式(协同)</li>
</ul>
</li>
<li>进程通信</li>
<li>调度<ul>
<li>作业调度</li>
<li>进程调度</li>
</ul>
</li>
</ul>
</li>
<li><p>2.存储器管理功能</p>
<ul>
<li>内存分配<ul>
<li>静态分配</li>
<li>动态分配</li>
</ul>
</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充</li>
</ul>
</li>
<li><p>3.设备管理功能</p>
<ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理<ul>
<li>设备处理程序又称设备驱动程序</li>
</ul>
</li>
</ul>
</li>
<li><p>4.文件管理功能</p>
<ul>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件的读写管理和保护</li>
</ul>
</li>
<li><p>5.操作系统与用户之间的接口</p>
<ul>
<li>用户接口</li>
<li>程序接口</li>
</ul>
</li>
<li><p>6.现代操作系统的新功能</p>
<ul>
<li>系统安全</li>
<li>网络的功能和服务</li>
<li>支持多媒体<h3 id="5-OS结构设计"><a href="#5-OS结构设计" class="headerlink" title="5.OS结构设计"></a>5.OS结构设计</h3></li>
</ul>
</li>
<li><p>传统操作系统结构</p>
<ul>
<li>无结构操作系统</li>
<li>模块化OS</li>
<li>分层式结构OS</li>
</ul>
</li>
<li><p>微内核os结构</p>
<ul>
<li>客户/服务器模式</li>
<li>面对对象的程序设计<h2 id="第二章进程的描述与控制"><a href="#第二章进程的描述与控制" class="headerlink" title="第二章进程的描述与控制"></a>第二章进程的描述与控制</h2><h3 id="前驱图和程序执行"><a href="#前驱图和程序执行" class="headerlink" title="前驱图和程序执行"></a>前驱图和程序执行</h3><h3 id="程序并发执行"><a href="#程序并发执行" class="headerlink" title="程序并发执行"></a>程序并发执行</h3></li>
</ul>
</li>
<li><p>程序的并发执行</p>
</li>
<li><p>程序并发执行时的特征</p>
<ul>
<li>间断性</li>
<li>失去封闭性</li>
<li>不可再现性<h3 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h3></li>
</ul>
</li>
<li><p>进程的定义</p>
<ul>
<li>进程是程序的一次执行</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>
</ul>
</li>
<li><p>进程的特征</p>
<ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ul>
</li>
<li><p>从操作系统角度分类</p>
<ul>
<li>系统进程</li>
<li>用户进程</li>
</ul>
</li>
<li><p>进程和程序的区别</p>
<ul>
<li>进程是动态概念，而程序则是静态概念</li>
<li>程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；</li>
<li>进程具有并发性，而程序没有</li>
<li>进程可创建其他进程，而程序并不能形成新的程序</li>
<li>进程是竞争计算机资源的基本单位，程序不是</li>
</ul>
</li>
<li><p>进程和程序的联系</p>
<ul>
<li>进程是程序在数据集上的一次执行</li>
<li>程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序</li>
<li>进程的运行目标是执行所对应的程序</li>
<li>从静态看，进程由程序、数据和进程控制块（PCB）组成</li>
</ul>
</li>
<li><p>进程的基本状态及转换</p>
<ul>
<li>进程的三种基本状态<ul>
<li>就绪状态ready</li>
<li>执行状态running</li>
<li>阻塞状态block</li>
</ul>
</li>
<li>三种基本状态的转换</li>
<li>创建状态和终止状态<ul>
<li>五状态进程模型</li>
</ul>
</li>
<li>注意<ul>
<li>阻塞态-&gt;运行态和就绪态-&gt;阻塞态这二种状态转换不可能发生</li>
</ul>
</li>
</ul>
</li>
<li><p>挂起操作和进程状态的转换</p>
<ul>
<li>挂起和阻塞的区别</li>
<li>挂起操作的目的<ul>
<li>终端用户的需要: 修改、检查进程</li>
<li>父进程的需要：修改、协调子进程</li>
<li>对换的需要：缓和内存</li>
<li>负荷调节的需要：保证实时任务的执行</li>
</ul>
</li>
<li>关键图</li>
</ul>
</li>
<li><p>进程管理中的数据结构</p>
<ul>
<li>进程控制块PCB的作用<ul>
<li>作为独立运行基本单位的标志</li>
<li>能实现间断性运行方式</li>
<li>提供进程管理所需要的信息</li>
<li>提供进程调度所需要的信息</li>
<li>实现与其他进程的同步与通信</li>
</ul>
</li>
<li>进程控制块的信息<ul>
<li>进程标识符<ul>
<li>外部标识符PID</li>
<li>内部标识符(端口)</li>
</ul>
</li>
<li>处理机状态<ul>
<li>通用寄存器</li>
<li>指令计数器</li>
<li>程序状态字PSW</li>
<li>用户栈指针</li>
</ul>
</li>
<li>进程调度信息<ul>
<li>进程状态</li>
<li>进程优先级</li>
<li>进程调度所需的其他信息</li>
<li>事件</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>程序和数据的地址</li>
<li>进程同步和通信机制</li>
<li>资源清单</li>
<li>链接指针</li>
</ul>
</li>
<li>进程控制块的组织方式<ul>
<li>线性方式</li>
<li>链接方式</li>
<li>索引方式<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作系统内核</p>
<ul>
<li>两大功能<ul>
<li>支撑功能<ul>
<li>中断管理</li>
<li>时钟管理</li>
<li>原语操作<ul>
<li>进程的管理，由若干原语（primitive）来执行</li>
</ul>
</li>
</ul>
</li>
<li>资源管理功能<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
</li>
</ul>
</li>
<li>状态<ul>
<li>系统态，管态，内核态</li>
<li>用户态，目态</li>
</ul>
</li>
</ul>
</li>
<li><p>进程的创建</p>
<ul>
<li>进程的层次结构<ul>
<li>父进程</li>
<li>子进程</li>
</ul>
</li>
<li>引起创建进程的事件<ul>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ul>
</li>
<li>进程的创建过程<ul>
<li>1.申请空白PCB</li>
<li>2.为新进程分配其运行所需的资源</li>
<li>3.初始化进程块PCB</li>
<li>4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列</li>
</ul>
</li>
<li>进程的终止<ul>
<li>引起进程终止的事件<ul>
<li>1.正常结束</li>
<li>2.异常结束</li>
<li>3.外界干预</li>
</ul>
</li>
<li>进程的终止过程<ul>
<li>1.根据被终止进程的标识符</li>
</ul>
</li>
</ul>
</li>
<li>进程的阻塞与唤醒<ul>
<li>引起进程阻塞和唤醒的事件<ul>
<li>请求系统服务而未满足</li>
<li>启动某种操作而阻塞当前进程</li>
<li>新数据尚未到达</li>
<li>无新工作可做：系统进程</li>
</ul>
</li>
<li>进程阻塞过程(自己阻塞自己)</li>
<li>进程唤醒过程(系统或其他进程唤醒自己)</li>
</ul>
</li>
<li>进程的挂起与激活<ul>
<li>suspend</li>
<li>active</li>
</ul>
</li>
</ul>
</li>
<li><p>进程同步</p>
<ul>
<li>基本概念<ul>
<li>两种形式的制约关系<ul>
<li>间接相互制约关系<ul>
<li>互斥——竞争</li>
</ul>
</li>
<li>直接相互制约关系<ul>
<li>同步——协作</li>
</ul>
</li>
</ul>
</li>
<li>临界资源</li>
<li>分区<ul>
<li>进入区enter section</li>
<li>临界区critical section</li>
<li>退出区exit section</li>
<li>剩余区remainder section</li>
</ul>
</li>
<li>同步机制应遵循的规则<ul>
<li>1.空闲让进</li>
<li>2.忙则等待</li>
<li>3.有限等待</li>
<li>4.让权等待</li>
</ul>
</li>
</ul>
</li>
<li>进程同步机制<ul>
<li>软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况</li>
<li>硬件同步机制<ul>
<li>关中断</li>
<li>利用Test-and-Set指令实现互斥</li>
<li>利用swap指令实现进程互斥</li>
</ul>
</li>
<li>信号量机制<ul>
<li>整型信号量</li>
<li>记录型信号量<ul>
<li>由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表</li>
</ul>
</li>
<li>AND型信号量</li>
<li>信号量集<ul>
<li>理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配</li>
<li>操作<ul>
<li>Swait(S1，t1，d1…Sn，tn，dn)</li>
<li>Ssignal(S1，d1…Sn，dn)</li>
</ul>
</li>
<li>特殊情况</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>经典进程的同步问题<ul>
<li>生产者–消费者问题</li>
<li>哲学家进餐问题</li>
<li>读者–写者问题<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>进程通信是指进程之间的信息交换，又称低级进程通信</p>
</li>
<li><p>进程通信的类型</p>
<ul>
<li>共享存储器系统<ul>
<li>基于共享数据结构的通信方式<ul>
<li>生产者和消费者</li>
</ul>
</li>
<li>基于共享存储区的通信方式<ul>
<li>高级通信</li>
</ul>
</li>
</ul>
</li>
<li>管道通信系统(pipe)<ul>
<li>高级通信</li>
</ul>
</li>
<li>消息传递系统<ul>
<li>高级通信</li>
<li>方式分类<ul>
<li>直接通信</li>
<li>间接通信</li>
</ul>
</li>
</ul>
</li>
<li>客服机–服务器系统</li>
</ul>
</li>
<li><p>消息传递通信的实现方式</p>
<ul>
<li>直接消息传递系统</li>
<li>信箱通信<h3 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h3></li>
</ul>
</li>
<li><p>线程的引入</p>
<ul>
<li>线程的引入正是为了简化线程间的通信，以小的开销来提高进程内的并发程度</li>
<li>多线程并发的不足<ul>
<li>进程的两个基本属性<ul>
<li>一个拥有资源的独立单位，可独立分配系统资源</li>
<li>一个可独立调度和分派的基本单位，PCB</li>
</ul>
</li>
<li>程序并发执行所需付出的时空开销<ul>
<li>创建进程</li>
<li>撤销进程</li>
<li>进程切换</li>
</ul>
</li>
<li>进程间通信效率低</li>
<li>将分配资源和调度两个属性分开</li>
</ul>
</li>
<li>线程——作为调度和分派的基本单位<ul>
<li>进程是系统资源分配的单位，线程是处理器调度的单位</li>
<li>线程表示进程的一个控制点，可以执行一系列的指令。通常，和应用程序的一个函数相对应</li>
<li>进程分解为线程还可以有效利用多处理器和多核计算机</li>
</ul>
</li>
</ul>
</li>
<li><p>线程与进程的比较</p>
<ul>
<li>不同点<ul>
<li>调度的基本单位</li>
<li>并发性</li>
</ul>
</li>
<li>相似点<ul>
<li>状态：运行、阻塞、就绪</li>
<li>线程具有一定的生命期</li>
<li>进程可创建线程，一个线程可创建另一个子线程</li>
<li>多个线程并发执行时仍然存在互斥与同步</li>
</ul>
</li>
</ul>
</li>
<li><p>线程的实现</p>
<ul>
<li>线程的实现方式<ul>
<li>内核支持线程KST</li>
<li>用户级线程ULT</li>
<li>组合方式</li>
</ul>
</li>
<li>多线程OS中的进程属性<ul>
<li>进程是一个可拥有资源的基本单位</li>
<li>多个线程可并发执行</li>
<li>进程已不是可执行的实体</li>
</ul>
</li>
<li>线程的状态和线程控制块<ul>
<li>线程运行的三个状态<ul>
<li>执行状态</li>
<li>就绪状态</li>
<li>阻塞状态</li>
</ul>
</li>
<li>线程控制块TCB<h2 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章:处理机调度与死锁"></a>第三章:处理机调度与死锁</h2><h3 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>处理机调度算法的共同目标</p>
<ul>
<li>资源利用率:CPU的利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)</li>
<li>公平性</li>
<li>平衡性</li>
<li>策略强制执行</li>
</ul>
</li>
<li><p>批处理系统的目标</p>
<ul>
<li>平均周转时间短</li>
<li>系统吞吐量高</li>
<li>处理机利用率高</li>
</ul>
</li>
<li><p>分时系统的目标</p>
<ul>
<li>响应时间快</li>
<li>均衡性</li>
</ul>
</li>
<li><p>实时系统目标</p>
<ul>
<li>截止时间的保证</li>
<li>可预测性</li>
</ul>
</li>
<li><p>处理机调度的层次</p>
<ul>
<li>高级调度（作业调度）<ul>
<li>分时系统无需作业调度，因为需要交互</li>
<li>批处理系统需要作业调度</li>
</ul>
</li>
<li>中级调度（和挂起有关）</li>
<li>低级调度（进程调度）<ul>
<li>进程调度是最基本的调度，任何操作系统都有进程调度。</li>
<li>低级调度的三个基本机制<ul>
<li>排队器</li>
<li>分派器</li>
<li>上下文切换</li>
</ul>
</li>
<li>进程调度方式<ul>
<li>非抢占方式</li>
<li>抢占方式<ul>
<li>优先权原则</li>
<li>短进程优先原则</li>
<li>时间片原则</li>
</ul>
</li>
</ul>
</li>
<li>进程调度的任务<ul>
<li>保存处理机的现场信息</li>
<li>按某种算法选取进程</li>
<li>把处理器分配给进程</li>
</ul>
</li>
<li>进程调度的算法<ul>
<li>优先级调度算法<ul>
<li>优先级调度算法的类型<ul>
<li>非抢占式优先级调度算法<ul>
<li>等当前进程执行完以后，再执行另一个优先权最高的进程</li>
<li>这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 </li>
</ul>
</li>
<li>抢占式优先级调度算法<ul>
<li>不等当前进程结束，直接抢处理机</li>
<li>常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。</li>
</ul>
</li>
</ul>
</li>
<li>优先级的类型<ul>
<li>静态优先级<ul>
<li>优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0<del>7或0</del>255中的某一整数， 又把该整数称为优先数。</li>
<li>可以参考BIOS系统中设置boot的优先级</li>
</ul>
</li>
<li>动态优先级<ul>
<li>在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>轮转调度算法<ul>
<li>基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行</li>
<li>进程切换时机<ul>
<li>时间片未用完，进程完成</li>
<li>时间片到，进程未完成</li>
</ul>
</li>
<li>时间片大小的确定<ul>
<li>太小利于短作业，增加系统切换开销</li>
<li>太长就退化为FCFS算法</li>
<li>一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成</li>
</ul>
</li>
<li>一般来说，平均周转时间将比SJF长，但是有较好的响应时间</li>
</ul>
</li>
<li>多队列调度算法</li>
<li>多级反馈队列调度算法<ul>
<li>调度机制<ul>
<li>设置多个就绪队列</li>
<li>每个队列都采用FCFS算法</li>
<li>按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行</li>
</ul>
</li>
<li>调度算法的性能<ul>
<li>对于终端型用户，由于作业小，感觉满意</li>
<li>对于短批处理作业用户，周转时间也较小</li>
<li>长批处理作业用户，也能够得到执行</li>
</ul>
</li>
</ul>
</li>
<li>基于公平原则的调度算法<ul>
<li>保证调度算法</li>
<li>公平分享调度算法<h3 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>作业</p>
<ul>
<li>作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。</li>
</ul>
</li>
<li><p>作业控制块JCB</p>
<ul>
<li>为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。</li>
</ul>
</li>
<li><p>作业步</p>
<ul>
<li>作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。</li>
</ul>
</li>
<li><p>作业运行的三个阶段</p>
<ul>
<li>收容阶段</li>
<li>运行阶段</li>
<li>完成阶段</li>
</ul>
</li>
<li><p>作业运行的三个状态</p>
<ul>
<li>后备状态</li>
<li>运行状态</li>
<li>完成状态</li>
</ul>
</li>
<li><p>作业调度的主要任务</p>
<ul>
<li>接纳多少个作业</li>
<li>接纳哪些作业</li>
</ul>
</li>
<li><p>先来先服务(first–come first–served，FCFS)调度算法</p>
<ul>
<li>比较有利于长作业，而不利于短作业。</li>
<li>有利于CPU繁忙的作业，而不利于I/O繁忙的作业。</li>
</ul>
</li>
<li><p>短作业优先(short job first，SJF)的调度算法</p>
<ul>
<li>优点<ul>
<li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li>
<li>提高系统的吞吐量；</li>
</ul>
</li>
<li>缺点<ul>
<li>必须预知作业的运行时间</li>
<li>对长作业非常不利，长作业的周转时间会明显地增长</li>
<li>在采用SJF算法时，人–机无法实现交互</li>
<li>该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理</li>
</ul>
</li>
</ul>
</li>
<li><p>优先级调度算法(priority–scheduling algorithm，PSA)</p>
</li>
<li><p>高响应比优先调度算法(Highest Response Ratio Next,HRRN)</p>
<ul>
<li>原理<ul>
<li>在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行</li>
<li>优先权=(等待时间+要求服务时间)/要求服务时间=响应时间/要求服务时间=1+等待时间/要求服务时间</li>
</ul>
</li>
<li>特点<ul>
<li>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业</li>
<li>当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法</li>
<li>对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机<h3 id="实时调度-HRT和SRT任务"><a href="#实时调度-HRT和SRT任务" class="headerlink" title="实时调度(HRT和SRT任务)"></a>实时调度(HRT和SRT任务)</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>实现实时调度的基本条件</p>
<ul>
<li>提供必要信息<ul>
<li>就绪时间</li>
<li>开始截止时间和完成截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ul>
</li>
<li>系统处理能力强<ul>
<li>∑(Ci/Pi)≤1</li>
<li>N个处理机:∑(Ci/Pi)≤N</li>
</ul>
</li>
<li>采用抢占式调度机制</li>
<li>具有快速切换机制<ul>
<li>对中断的快速响应能力</li>
<li>快速的任务分派能力</li>
</ul>
</li>
</ul>
</li>
<li><p>实时调度算法的分类</p>
<ul>
<li>非抢占式调度算法<ul>
<li>非抢占式轮转调度算法</li>
<li>非抢占式优先调度算法</li>
</ul>
</li>
<li>抢占式调度算法<ul>
<li>基于时钟中断的抢占式优先级调度算法</li>
<li>立即抢占的优先级调度算法</li>
</ul>
</li>
</ul>
</li>
<li><p>最早截止时间优先EDF(Earliest Deadline First)算法</p>
<ul>
<li>根据任务的开始截至时间来确定任务的优先级<ul>
<li>截至时间越早，优先级越高</li>
</ul>
</li>
<li>非抢占式调度方式用于非周期实时任务</li>
<li>抢占式调度方式用于周期实时任务</li>
</ul>
</li>
<li><p>最低松弛度优先LLF(Least Laxity First)算法</p>
<ul>
<li>类似EDF</li>
<li>算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。</li>
<li>松弛度例子<ul>
<li>例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms</li>
</ul>
</li>
</ul>
</li>
<li><p>优先级倒置(Priority inversion problem)</p>
<ul>
<li>优先级倒置的形成<ul>
<li>高优先级进程被低优先级进程延迟或阻塞。</li>
</ul>
</li>
<li>优先级倒置的解决方法<ul>
<li>简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占</li>
<li>实用的:建立在动态优先级继承基础上的<h3 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>资源问题</p>
<ul>
<li>可重用性资源<ul>
<li>计算机外设</li>
</ul>
</li>
<li>消耗性资源<ul>
<li>数据，消息</li>
</ul>
</li>
<li>可抢占性资源<ul>
<li>不引起死锁</li>
<li>CPU，内存 </li>
</ul>
</li>
<li>不可抢占性资源<ul>
<li>光驱，打印机</li>
</ul>
</li>
</ul>
</li>
<li><p>计算机系统中的死锁</p>
<ul>
<li>竞争不可抢占性资源引起死锁</li>
<li>竞争可消耗资源引起死锁</li>
<li>进程推进顺序不当引起死锁</li>
</ul>
</li>
<li><p>死锁的定义，必要条件和处理方法</p>
<ul>
<li>定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的</li>
<li>产生死锁的必要条件<ul>
<li>互斥条件</li>
<li>请求和保存条件</li>
<li>不可抢占条件</li>
<li>循环等待条件<ul>
<li>如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件</li>
</ul>
</li>
</ul>
</li>
<li>处理死锁的方法<ul>
<li>预防死锁<ul>
<li>静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。</li>
<li>预防死锁的策略<ul>
<li>破坏”请求和保存”条件<ul>
<li>第一种协议<ul>
<li>所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源</li>
<li>优点:简单，易行，安全</li>
<li>缺点<ul>
<li>资源被严重浪费，严重地恶化了资源的利用率</li>
<li>使进程经常会发生饥饿现象</li>
</ul>
</li>
</ul>
</li>
<li>第二种协议<ul>
<li>它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源</li>
</ul>
</li>
</ul>
</li>
<li>破坏”不可抢占”条件<ul>
<li>当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请</li>
</ul>
</li>
<li>破坏”循环等待”条件<ul>
<li>对系统所以资源类型进行线性排序，并赋予不同的序号</li>
<li>例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>避免死锁<ul>
<li>动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法</li>
<li>避免死锁的策略<ul>
<li>系统安全状态<ul>
<li>安全状态<ul>
<li>某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如&lt;p1,p2…pn&gt;来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列</li>
</ul>
</li>
<li>安全状态之例</li>
<li>由安全状态向不安全状态的转换</li>
</ul>
</li>
<li>利用银行家算法避免死锁<ul>
<li>含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待</li>
<li>银行家算法中的数据结构<ul>
<li>可用资源向量 Available[m]：m为系统中资源种类数，Available[j]=k表示系统中第j类资源数为k个。</li>
<li>最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]=k表示进程i对j类资源的最大需求数为中k。</li>
<li>分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] = k表示进程i已分得j类资源的数目为k个。</li>
<li>需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]=k 表示进程i   还需要j类资源k个。Need[i,j]=Max[i,j] - Allocation[i,j]</li>
</ul>
</li>
<li>银行家算法</li>
<li>安全性算法</li>
<li>银行家算法之例</li>
<li>解题<ul>
<li>矩阵</li>
<li>列表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>检测死锁<ul>
<li>死锁的检测与解除<ul>
<li>死锁的检测<ul>
<li>资源分配图<ul>
<li>简化步骤<ul>
<li>选择一个没有阻塞的进程p</li>
<li>将p移走，包括它的所有请求边和分配边</li>
<li>重复步骤1，2，直至不能继续下去</li>
</ul>
</li>
</ul>
</li>
<li>死锁定理<ul>
<li>若一系列简化以后不能使所有的进程节点都成为孤立节点</li>
</ul>
</li>
<li>检测时机<ul>
<li>当进程等待时检测死锁 （其缺点是系统的开销大）</li>
<li>定时检测</li>
<li>系统资源利用率下降时检测死锁</li>
</ul>
</li>
<li>死锁检测中的数据结构</li>
</ul>
</li>
<li>死锁的解除<ul>
<li>抢占资源</li>
<li>终止(或撤销)进程</li>
<li>终止进程的方法<ul>
<li>终止所有死锁进程</li>
<li>逐个终止进程<ul>
<li>代价最小<ul>
<li>进程的优先级的大小</li>
<li>进程已执行了多少时间，还需时间</li>
<li>进程在运行中已经使用资源的多少，还需多少资源</li>
<li>进程的性质是交互式还是批处理的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>付出代价最小的死锁解除算法<ul>
<li>是使用一个有效的挂起和解除机构来挂起一些死锁的进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>解除死锁<h2 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章:存储器管理"></a>第四章:存储器管理</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>多层结构的存储系统</p>
<ul>
<li>存储器的多层结构<ul>
<li>CPU寄存器</li>
<li>主存</li>
<li>辅存</li>
</ul>
</li>
<li>可执行存储器<ul>
<li>寄存器和主存的总称</li>
<li>访问速度快，进程可以在很少的时钟周期内用一条load或store指令完成存取。</li>
</ul>
</li>
</ul>
</li>
<li><p>主存储器与寄存器</p>
</li>
<li><p>高速缓存和磁盘缓存</p>
<h3 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h3></li>
<li><p>步骤</p>
<ul>
<li>编译<ul>
<li>源程序 -&gt;目标模块（Object modules）——–Compiler<ul>
<li>由编译程序对用户源程序进行编译，形成若干个目标模块</li>
</ul>
</li>
</ul>
</li>
<li>链接<ul>
<li>一组目标模块 -&gt;装入模块 （Load Module）———-Linker<ul>
<li>由链接程序将编译后形成的一组目标模板以及它们所需要的库函数链接在一起，形成一个完整的装入模块</li>
</ul>
</li>
</ul>
</li>
<li>装入<ul>
<li>装入模块 -&gt;内存  ——–Loader<ul>
<li>由装入程序将装入模块装入内存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>程序的装入</p>
<ul>
<li>绝对装入方式<ul>
<li>在编译时，如果知道程序将驻留在内存中指定的位置。编译程序将产生绝对地址的目标代码。</li>
</ul>
</li>
<li>可重定位装入方式<ul>
<li>在可执行文件中，列出各个需要重定位的地址单元和相对地址值。当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换(一般在装入内存时由软件完成)。</li>
<li>优点：不需硬件支持，可以装入有限多道程序。</li>
<li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。不易实现共享。</li>
</ul>
</li>
<li>动态运行时的装入方式<ul>
<li>动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行</li>
<li>优点：<ul>
<li>OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利用实现共享。</li>
<li>能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）。</li>
</ul>
</li>
<li>缺点：需要硬件支持，OS实现较复杂。</li>
<li>它是虚拟存储的基础。</li>
</ul>
</li>
</ul>
</li>
<li><p>程序的链接</p>
<ul>
<li>静态链接方式(lib)</li>
<li>装入时动态链接</li>
<li>运行时动态链接(dll)<h3 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h3></li>
</ul>
</li>
<li><p>连续分配</p>
<ul>
<li>单一连续分配(DOS)</li>
<li>固定分区分配(浪费很多空间)</li>
<li>动态分区分配</li>
</ul>
</li>
<li><p>地址映射和存储保护措施</p>
<ul>
<li>基址寄存器：程序的最小物理地址</li>
<li>界限寄存器：程序的逻辑地址范围</li>
<li>物理地址 = 逻辑地址 + 基址</li>
</ul>
</li>
<li><p>内碎片：占用分区之内未被利用的空间</p>
</li>
<li><p>外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）</p>
</li>
<li><p>把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。</p>
<ul>
<li>分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。</li>
<li>分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</li>
<li>优点：无外碎片、易实现、开销小。</li>
<li>缺点：<ul>
<li>存在内碎片，造成浪费</li>
<li>分区总数固定，限制了并发执行的程序数目。</li>
<li>通用Os很少采用，部分控制系统中采用</li>
</ul>
</li>
</ul>
</li>
<li><p>动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。</p>
<ul>
<li>基于顺序搜索的动态分区分配算法<ul>
<li>首次适应算法（first fit,FF）<ul>
<li>顺序找，找到一个满足的就分配，但是可能存在浪费</li>
<li>这种方法目的在于减少查找时间。</li>
<li>空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序</li>
</ul>
</li>
<li>循环首次适应算法（next fit，NF）<ul>
<li>相对上面那种，不是顺序，类似哈希算法中左右交叉排序</li>
<li>空闲分区分布得更均匀，查找开销小</li>
<li>从上次找到的空闲区的下一个空闲区开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。</li>
</ul>
</li>
<li>最佳适应算法（best fit，BF）<ul>
<li>找到最合适的，但是大区域的访问次数减少</li>
<li>这种方法能使外碎片尽量小。</li>
<li>空闲分区表（空闲区链）中的空闲分区要按大小从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。</li>
</ul>
</li>
<li>最坏适应算法（worst fit，WF）<ul>
<li>相对于最好而言，找最大的区域下手，导致最大的区域可能很少，也造成许多碎片</li>
<li>空闲分区按大小由大到小排序</li>
</ul>
</li>
</ul>
</li>
<li>基于索引搜索的动态分区分配算法<ul>
<li>快速适应算法（quick fit）</li>
<li>伙伴系统（buddy system）</li>
<li>哈希算法</li>
</ul>
</li>
<li>动态可重定位分区分配<ul>
<li>紧凑</li>
<li>动态重定位<ul>
<li>动态运行时装入，地址转化在指令执行时进行，需获得硬件地址变换机制的支持</li>
<li>内存地址=相对地址+起始地址</li>
</ul>
</li>
<li>动态重定位分区分配算法<ul>
<li>1、在某个分区被释放后立即进行紧凑，系统总是只有一个连续的分区而无碎片，此法很花费机时。</li>
<li>2、当“请求分配模块”找不到足够大的自由分区分给用户时再进行紧凑，这样紧缩的次数比上种方法少得多，但管理复杂。采用此法的动态重定位分区分配算法框图如下：</li>
</ul>
</li>
</ul>
</li>
<li>优点：没有内碎片。</li>
<li>缺点：外碎片。<h3 id="对换（了解）"><a href="#对换（了解）" class="headerlink" title="对换（了解）"></a>对换（了解）</h3></li>
</ul>
</li>
<li><p>系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。</p>
<h3 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h3></li>
<li><p>分页存储管理的基本方式</p>
<ul>
<li>页面<ul>
<li>将一个进程的逻辑地址空间分成若干个大小相等的片</li>
</ul>
</li>
<li>页框（frame）<ul>
<li>内存空间分成与页面相同大小的存储块</li>
</ul>
</li>
<li>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”</li>
<li>地址结构<ul>
<li>页号P+位移量W(0-31)</li>
</ul>
</li>
<li>页表<ul>
<li>在分页系统中，允许将进程的各个页离散地存储在内存在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每一个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表</li>
<li>页表的作用是实现从页面号到物理块号的地址映射</li>
</ul>
</li>
</ul>
</li>
<li><p>地址变换机构</p>
<ul>
<li>基本的地址变换机构<ul>
<li>要访问两次内存</li>
<li>页表大都驻留在内存中</li>
<li>为了实现地址变换功能，在系统中设置页表寄存器（PTR），用来存放页表的始址和页表的长度。</li>
<li>在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。</li>
</ul>
</li>
<li>具有快表的地址变换机构<ul>
<li>提高了效率，此处会有计算题</li>
<li>如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样CPU存一个数据必须访问两次内存，从而使计算机的处理速度降低了1/2。</li>
<li>为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。</li>
<li>地址变换过程为：<ul>
<li>1、CPU给出有效地址</li>
<li>2、地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中。</li>
<li>3、若是，则直接读出该页所对应的物理块号，送入物理地址寄存器；</li>
<li>4、若快表中未找到对应的页表项，则需再访问内存中的页表</li>
<li>5、找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>两级和多级页表</p>
<ul>
<li>主要是有的时候页表太多了，要化简</li>
<li>格式：外层页号P1+外层页内地址P2+页内地址d</li>
<li>基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。</li>
</ul>
</li>
<li><p>反置页表</p>
<ul>
<li>反置页表为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>没有外碎片，每个内碎片不超过页大小。</li>
<li>一个程序不必连续存放。</li>
<li>便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。</li>
</ul>
</li>
<li><p>缺点：程序全部装入内存。</p>
<h3 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h3></li>
<li><p>引入</p>
<ul>
<li>方便编程</li>
<li>信息共享</li>
<li>动态增长</li>
<li>动态链接</li>
</ul>
</li>
<li><p>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。</p>
</li>
<li><p>内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定</p>
</li>
<li><p>分段系统的基本原理</p>
<ul>
<li>分段<ul>
<li>格式：段号+段内地址</li>
</ul>
</li>
<li>段表<ul>
<li>段表实现了从逻辑段到物理内存区的映射。</li>
</ul>
</li>
<li>地址变换机构</li>
</ul>
</li>
<li><p>和分页的区别</p>
<ul>
<li>页是信息的物理单位</li>
<li>页的大小固定且由系统固定</li>
<li>分页的用户程序地址空间是一维的</li>
<li>通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</li>
<li>分页是系统管理的需要，分段是用户应用的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li>
</ul>
</li>
<li><p>信息共享</p>
<ul>
<li>这是分段最重要的优点</li>
</ul>
</li>
<li><p>段页式存储管理方式</p>
<ul>
<li>基本原理<ul>
<li>格式：段号（S）+段内页号（P）+页内地址（W）</li>
</ul>
</li>
<li>地址变换过程<ul>
<li>需要三次访问过程</li>
</ul>
</li>
<li>在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。<h2 id="第五章：虚拟存储器"><a href="#第五章：虚拟存储器" class="headerlink" title="第五章：虚拟存储器"></a>第五章：虚拟存储器</h2><h3 id="常规存储管理方式的特征"><a href="#常规存储管理方式的特征" class="headerlink" title="常规存储管理方式的特征"></a>常规存储管理方式的特征</h3></li>
</ul>
</li>
<li><p>一次性</p>
</li>
<li><p>驻留性</p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3></li>
<li><p>程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域</p>
</li>
<li><p>时间局限性</p>
<ul>
<li>如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作</li>
</ul>
</li>
<li><p>空间局限性</p>
<ul>
<li>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3></li>
</ul>
</li>
<li><p>指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li>
<li><p>大程序：可在较小的可用内存中执行较大的用户程序；</p>
</li>
<li><p>大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)</p>
</li>
<li><p>并发：可在内存中容纳更多程序并发执行；</p>
</li>
<li><p>易于开发：不必影响编程时的程序结构</p>
</li>
<li><p>以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3></li>
<li><p>离散性</p>
<ul>
<li>指在内存分配时采用离散的分配方式，它是虚拟存储器的实现的基础</li>
</ul>
</li>
<li><p>多次性</p>
<ul>
<li>指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器最重要的特征</li>
</ul>
</li>
<li><p>对换性</p>
<ul>
<li>指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。</li>
</ul>
</li>
<li><p>虚拟性</p>
<ul>
<li>指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。<h3 id="虚拟存储器的实现方式"><a href="#虚拟存储器的实现方式" class="headerlink" title="虚拟存储器的实现方式"></a>虚拟存储器的实现方式</h3></li>
</ul>
</li>
<li><p>请求分页存储管理方式</p>
<ul>
<li>硬件<ul>
<li>请求页表机制<ul>
<li>格式：页号+物理块号+状态位P+访问字段A+修改位M+外存地址</li>
</ul>
</li>
<li>缺页中断机构</li>
<li>地址变换机构（过程图很关键）</li>
</ul>
</li>
<li>请求分页中的内存分配<ul>
<li>最小物理块数<ul>
<li>即能保证进程正常运行所需的最小物理块数</li>
</ul>
</li>
<li>内存分配策略<ul>
<li>固定分配局部置换（国王的大儿子）</li>
<li>可变分配全局置换（国王的二儿子）</li>
<li>可变分配局部置换（国王的小儿子）</li>
</ul>
</li>
</ul>
</li>
<li>物理块分配算法<ul>
<li>平均分配算法</li>
<li>按比例分配算法</li>
<li>考虑优先权的分配算法</li>
</ul>
</li>
<li>页面调入策略<ul>
<li>系统应在何时调入所需页面<ul>
<li>预调页策略（不能实现）</li>
<li>请求调页策略（需要才给）</li>
</ul>
</li>
<li>系统应该从何处调入这些页面<ul>
<li>对换区</li>
<li>文件区</li>
</ul>
</li>
<li>页面调入过程</li>
<li>缺页率（出计算题）</li>
</ul>
</li>
</ul>
</li>
<li><p>请求分段系统</p>
<ul>
<li>硬件<ul>
<li>请求分段的段表机构</li>
<li>缺段中断机构</li>
<li>地址变换机构<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>抖动的概念</p>
<ul>
<li>即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出</li>
</ul>
</li>
<li><p>最佳置换算法(需要预知后面进程，所以不能实现)</p>
</li>
<li><p>先进先出页面置换算法（FIFO）</p>
<ul>
<li>选择在内存中驻留时间最久的页面予以淘汰</li>
</ul>
</li>
<li><p>最近最久未使用置换算法（LRU）Recently</p>
<ul>
<li>寄存器支持</li>
<li>特殊的栈结构</li>
</ul>
</li>
<li><p>最少使用置换算法（LFU）Frequently</p>
</li>
<li><p>clock置换算法（对访问位A的判断）</p>
<ul>
<li>改进型——增加对修改位M思维判断</li>
</ul>
</li>
<li><p>页面缓冲算法（PBA,page buffering algorithm）</p>
<ul>
<li>空闲页面链表</li>
<li>修改页面链表<h2 id="第六章：输入输出系统"><a href="#第六章：输入输出系统" class="headerlink" title="第六章：输入输出系统"></a>第六章：输入输出系统</h2><h3 id="I-O系统的功能，模型和接口"><a href="#I-O系统的功能，模型和接口" class="headerlink" title="I/O系统的功能，模型和接口"></a>I/O系统的功能，模型和接口</h3></li>
</ul>
</li>
<li><p>I/O系统管理的对象是I/O设备和相应的设备控制器。</p>
</li>
<li><p>I/O系统的基本功能</p>
<ul>
<li>隐藏物理设备的细节</li>
<li>与设备的无关性</li>
<li>提高处理机和I/O设备的利用率</li>
<li>对I/O设备进行控制</li>
<li>确保对设备的正确共享</li>
<li>错误处理</li>
</ul>
</li>
<li><p>I/O软件的层次结构</p>
<ul>
<li>用户层I/O软件</li>
<li>设备独立性软件</li>
<li>设备驱动程序（厂家开发）</li>
<li>中断处理程序</li>
<li>硬件</li>
</ul>
</li>
<li><p>I/O系统的分层</p>
<ul>
<li>中断处理程序</li>
<li>设备驱动程序</li>
<li>设备独立性软件</li>
</ul>
</li>
<li><p>I/O系统接口</p>
<ul>
<li>块设备接口<ul>
<li>指以数据块为单位来组织和传送数据信息的设备</li>
<li>典型的块设备是磁盘、光盘</li>
<li>块设备的基本特征<ul>
<li>①传输速率较高，通常每秒钟为几兆位；</li>
<li>②它是可寻址的，即可随机地读/写任意一块；</li>
<li>③磁盘设备的I/O采用DMA方式。</li>
</ul>
</li>
</ul>
</li>
<li>流设备接口<ul>
<li>又称字符设备指以单个字符为单位来传送数据信息的设备</li>
<li>这类设备一般用于数据的输入和输出，有交互式终端、打印机</li>
<li>字符设备的基本特征<ul>
<li>①传输速率较低；</li>
<li>②不可寻址，即不能指定输入时的源地址或输出时的目标地址；</li>
<li>③字符设备的I/O常采用中断驱动方式。</li>
</ul>
</li>
</ul>
</li>
<li>网络通信接口<ul>
<li>提供网络接入功能，使计算机能通过网络与其他计算机进行通信或上网浏览。<h3 id="I-O设备和设备控制器"><a href="#I-O设备和设备控制器" class="headerlink" title="I/O设备和设备控制器"></a>I/O设备和设备控制器</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>使用特性分<ul>
<li>存储设备</li>
<li>I/O设备</li>
</ul>
</li>
<li>传输速率分<ul>
<li>低速设备（几字节——几百字节）<ul>
<li>典型的设备有键盘、鼠标、语音的输入</li>
</ul>
</li>
<li>中速设备（数千——数万字节）<ul>
<li>典型的设备有行式打印机、激光打印机</li>
</ul>
</li>
<li>高速设备（数十万——千兆字节）<ul>
<li>典型的设备有磁带机、磁盘机、光盘机</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。</p>
<ul>
<li>数据信号：控制器 ←  设备 ←  控制器<ul>
<li>传送数据信号，输入、输出bit</li>
</ul>
</li>
<li>控制信号: 控制器  →  设备<ul>
<li>执行读、写操作的信号</li>
</ul>
</li>
<li>状态信号：设备当前使用状态</li>
</ul>
</li>
<li><p>设备控制器</p>
<ul>
<li>主要功能：控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换</li>
<li>基本功能<ul>
<li>接收和识别命令<ul>
<li>控制寄存器、命令译码器</li>
</ul>
</li>
<li>数据交换<ul>
<li>实现CPU与控制器，控制器与设备间的数据交换</li>
</ul>
</li>
<li>标识和报告设备的状态</li>
<li>地址识别<ul>
<li>配置地址译码器，识别不同的设备</li>
</ul>
</li>
<li>数据缓冲区</li>
<li>差错控制</li>
</ul>
</li>
<li>设备控制器的组成<ul>
<li>设备控制器与处理机（CPU）的接口<ul>
<li>实现CPU与设备控制器之间的通信</li>
</ul>
</li>
<li>设备控制器与设备的接口<ul>
<li>控制器可连接多个设备</li>
</ul>
</li>
<li>I/O逻辑<ul>
<li>实现对设备的控制</li>
<li>CPU利用该逻辑向控制器发送I/O命令</li>
<li>命令、地址译码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内存映像I/O</p>
<ul>
<li>驱动程序将抽象I/O命令转换出的一系列具体的命令，参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I/O设备的操作</li>
</ul>
</li>
<li><p>I/O通道</p>
<ul>
<li><p>目的：建立独立的I/O操作(组织, 管理和结束)，使由CPU处理的I/O工作转由通道完成（解放CPU，实现并行）</p>
</li>
<li><p>什么是I/O通道？</p>
<ul>
<li>是一种特殊的处理机，具有通过执行通道程序完成I/O操作的指令</li>
<li>特点：指令单一(局限于与I/O操作相关的指令)，与CPU共享内存</li>
</ul>
</li>
<li><p>基本过程：</p>
<ul>
<li>CPU向通道发出I/O指令-&gt;通道接收指令-&gt;从内存取出通道程序处理I/O-&gt;向CPU发出中断</li>
</ul>
</li>
<li><p>通道类型</p>
<ul>
<li>字节多路通道<ul>
<li>低中速连接子通道时间片轮转方式共享主通道</li>
<li>字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。</li>
</ul>
</li>
<li>数组选择通道<ul>
<li>这种通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序， 控制一台设备进行数据传送， 直至该设备传送完毕释放该通道。这种通道的利用率很低。</li>
</ul>
</li>
<li>数组多路通道<ul>
<li>含有多个非分配型子通道，前两种通道的组合，通道利用率较好</li>
</ul>
</li>
</ul>
</li>
<li><p>瓶颈问题</p>
<ul>
<li>原因;通道不足</li>
<li>解决办法：增加设备到主机间的通路，而不增加通道（结果类似RS触发器）<h3 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>中断</p>
<ul>
<li>分类<ul>
<li>中断（外部触发）<ul>
<li>对外部I/O设备发出的中断信号的响应</li>
</ul>
</li>
<li>陷入（内部原因：除0）<ul>
<li>由CPU内部事件引起的中断</li>
</ul>
</li>
</ul>
</li>
<li>中断向量表（类比51单片机）<ul>
<li>中断程序的入口地址表</li>
</ul>
</li>
<li>中断优先级<ul>
<li>对紧急程度不同的中断处理方式</li>
</ul>
</li>
<li>对多中断源的处理方式<ul>
<li>屏蔽中断</li>
<li>嵌套中断</li>
</ul>
</li>
</ul>
</li>
<li><p>中断处理程序</p>
<ul>
<li>测定是否有未响应的中断信号</li>
<li>保护被中断进程的CPU环境</li>
<li>转入相应的设备处理程序</li>
<li>中断处理</li>
<li>恢复CPU 的现场并退出中断<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3></li>
</ul>
</li>
<li><p>是I/O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程</p>
</li>
<li><p>主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。</p>
</li>
<li><p>功能</p>
<ul>
<li>1) 接收由I/O进程发来的命令和参数， 并将命令中的抽象要求转换为具体要求。例如，将磁盘块号转换为磁盘的盘面、 磁道号及扇区号。</li>
<li>2) 检查用户I/O请求的合法性，了解I/O设备的状态，传递有关参数，设置设备的工作方式。 </li>
<li>3) 发出I/O命令，如果设备空闲，便立即启动I/O设备去完成指定的I/O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。</li>
<li>4) 及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。</li>
<li>5) 对于设置有通道的计算机系统，驱动程序还应能够根据用户的I/O请求，自动地构成通道程序。 </li>
</ul>
</li>
<li><p>设备驱动程序的处理过程</p>
<ul>
<li>将用户和上层软件对设备控制的抽象要求转换成对设备的具体要求，如对抽象要求的盘块号转换为磁盘的盘面、磁道及扇区。</li>
<li>检查I/O请求的合理性。</li>
<li>读出和检查设备的状态，确保设备处于就绪态。</li>
<li>传送必要的参数，如传送的字节数，数据在主存的首址等。</li>
<li>工作方式的设置。</li>
<li>启动I/O设备，并检查启动是否成功，如成功则将控制返回给I/O控制系统，在I/O设备忙于传送数据时，该用户进程把自己阻塞，直至中断到来才将它唤醒，而CPU可干别的事。</li>
</ul>
</li>
<li><p>对I/O设备的控制方式</p>
<ul>
<li>I/O控制的宗旨<ul>
<li>减少CPU对I/O控制的干预</li>
<li>充分利用CPU完成数据处理工作</li>
</ul>
</li>
<li>I/O 控制方式<ul>
<li>轮询的可编程I/O方式</li>
<li>中断驱动I/O方式</li>
<li>DMA控制方式</li>
<li>I/O通道控制方式</li>
</ul>
</li>
</ul>
</li>
<li><p>DMA控制器组成</p>
<ul>
<li>主机与DMA控制器的接口</li>
<li>DMA控制器与块设备的接口</li>
<li>I/O控制逻辑<h3 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I/O软件"></a>与设备无关的I/O软件</h3></li>
</ul>
</li>
<li><p>基本概念</p>
<ul>
<li>含义： 应用程序独立于具体使用的物理设备。</li>
<li>驱动程序是一个与硬件(或设备)紧密相关的软件。为实现设备独立性，须在驱动程序上设置一层软件，称为设备独立性软件。</li>
<li>设备独立性(Device Independence)的优点<ul>
<li>以物理设备名使用设备</li>
<li>引入了逻辑设备名</li>
<li>逻辑设备名称到物理设备名称的转换（易于实现I/O重定向）</li>
</ul>
</li>
</ul>
</li>
<li><p>与设备无关的软件</p>
<ul>
<li>设备驱动程序的统一接口</li>
<li>缓存管理</li>
<li>差错控制</li>
<li>对独立设备的分配与回收</li>
<li>独立于设备的逻辑数据块</li>
</ul>
</li>
<li><p>设备分配中的数据结构</p>
<ul>
<li>设备控制表DCT</li>
<li>控制器控制表COCT</li>
<li>通道控制表CHCT</li>
<li>显然，在有通道的系统中，一个进程只有获得了通道，控制器和所需设备三者之后，才具备了进行I/O操作的物理条件</li>
<li>系统设备表SDT</li>
<li>逻辑设备表LUT</li>
<li>分配的流程，从资源多的到资源紧张的:LUT-&gt;SDT-&gt;DCT-&gt;COCT-&gt;CHCT</li>
<li>在申请设备的过程中，根据用户请求的I/O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。<h3 id="用户层的I-O软件"><a href="#用户层的I-O软件" class="headerlink" title="用户层的I/O软件"></a>用户层的I/O软件</h3></li>
</ul>
</li>
<li><p>系统调用与库函数</p>
<ul>
<li>OS向用户提供的所有功能，用户进程都必须通过系统调用来获取</li>
<li>在C语言以及UNIX系统中，系统调用（如read）与各系统调用所使用的库函数（如read）之间几乎是一一对应的。而微软的叫Win32API</li>
</ul>
</li>
<li><p>假脱机系统（spooling）</p>
<ul>
<li>spooling技术是对脱机输入/输出系统的模拟</li>
<li>主要组成<ul>
<li>输入/输出井</li>
<li>输入/输出缓冲区</li>
<li>输入/输出进程</li>
<li>井管理程序</li>
</ul>
</li>
<li>特点（体现操作系统的虚拟性）<ul>
<li>提高了I/O的速度<ul>
<li>对数据所进行的I/O操作，已从对低速设备演变为对输入井或输出井中的数据存取。</li>
</ul>
</li>
<li>将独占设备改造为共享设备<ul>
<li>实际分给用户进程的不是打印设备，而是共享输出井中的存储区域 </li>
</ul>
</li>
<li>实现了虚拟设备功能<ul>
<li>将独占设备变成多台独占的虚拟设备。<h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>缓冲的引入（原因）</p>
<ul>
<li>缓和CPU与I/O设备间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li>
<li>提高CPU和I/O设备之间的并行性</li>
<li>解决数据粒度不匹配的问题</li>
</ul>
</li>
<li><p>单缓冲区</p>
<ul>
<li>即在CPU计算的时候，将数据数据输入到缓冲区(大小取决与T和C的大小)</li>
</ul>
</li>
<li><p>双缓冲区</p>
<ul>
<li>即允许CPU连续工作（T不断）</li>
</ul>
</li>
<li><p>环形缓冲区（专为生产者和消费者打造）</p>
<ul>
<li>组成<ul>
<li>多个缓冲区</li>
<li>多个指针</li>
</ul>
</li>
<li>使用<ul>
<li>Getbuf过程</li>
<li>Releasebuf过程</li>
</ul>
</li>
<li>同步问题</li>
</ul>
</li>
<li><p>缓冲池(理解为更大的缓冲区)</p>
<ul>
<li>组成<ul>
<li>空白缓冲队列（emq）<ul>
<li>由空缓冲区链接而成F(emq)，L(emq)分别指向该队列首尾缓冲区</li>
</ul>
</li>
<li>输入队列（inq）<ul>
<li>由装满输入数据的缓冲区链接而成F(inq)，L(inq)分别指向该队列首尾缓冲区</li>
</ul>
</li>
<li>输出队列（outq）<ul>
<li>由装满输出数据的缓冲区链接而成F(outq)， L(outq)分别指向该队列首尾缓冲</li>
</ul>
</li>
</ul>
</li>
<li>Getbuf和Putbuf过程<ul>
<li>收容：缓冲池接收外界数据</li>
<li>提取：外界从缓冲池获得数据</li>
</ul>
</li>
<li>缓冲区工作方式（从缓冲区的角度来看）<ul>
<li>收容输入</li>
<li>提取输入</li>
<li>收容输出</li>
<li>提取输出<h3 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>数据的组织和格式</p>
</li>
<li><p>磁盘的类型</p>
<ul>
<li>固定头磁盘（贵）</li>
<li>移动头磁盘</li>
</ul>
</li>
<li><p>磁盘访问的时间（关键）</p>
<ul>
<li>寻道时间Ts=m*n+s</li>
<li>旋转延迟时间Tr</li>
<li>传输时间Tt=b/rN</li>
<li>总时间Ta=Ts+1/2r+b/rN</li>
</ul>
</li>
<li><p>磁盘的调度算法（掌握图表）</p>
<ul>
<li>先来先服务（FCFS）<ul>
<li>优点：公平，简单</li>
<li>缺点：可能导致某些进程的请求长期得不到满足</li>
</ul>
</li>
<li>最短寻道时间优先（SSTF）<ul>
<li>说明：要求访问的磁道和当前磁头所在的磁道距离最近，以使每次的寻道时间最短</li>
</ul>
</li>
<li>扫描算法（SCAN）<ul>
<li>扫描算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁道当前的移动方向</li>
<li>联想电梯的运行</li>
<li>可防止低优先级进程出现“饥饿”的现象</li>
</ul>
</li>
<li>循环扫描算法（CSCAN）<ul>
<li>算法规定磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描</li>
</ul>
</li>
<li>NStepScan算法<ul>
<li>N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次这些子队列。</li>
</ul>
</li>
<li>FSCAN算法<ul>
<li>是Nstepscan算法的简化，将磁盘请求队列分成两个子队列<h2 id="第七章：文件管理"><a href="#第七章：文件管理" class="headerlink" title="第七章：文件管理"></a>第七章：文件管理</h2><h3 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>基本数据项</p>
</li>
<li><p>组合数据项</p>
<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3></li>
<li><p>记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3></li>
<li><p>文件类型</p>
</li>
<li><p>文件长度</p>
</li>
<li><p>文件的物理位置</p>
</li>
<li><p>文件的建立时间</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3></li>
<li><p>创建文件</p>
</li>
<li><p>删除文件</p>
</li>
<li><p>读文件</p>
</li>
<li><p>写文件</p>
</li>
<li><p>设置文件读写的位置</p>
<h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3></li>
<li><p>顺序文件</p>
</li>
<li><p>记录寻址</p>
</li>
<li><p>索引文件</p>
</li>
<li><p>索引顺序文件</p>
</li>
<li><p>直接文件和哈希文件</p>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3></li>
<li><p>文件控制块（FCB）</p>
<ul>
<li>文件名+inode(属性)</li>
</ul>
</li>
<li><p>简单的文件目录</p>
<ul>
<li>单级文件目录<ul>
<li>查找慢</li>
<li>不允许重名</li>
<li>不便于实现文件共享</li>
</ul>
</li>
<li>两级文件目录<ul>
<li>提高检索速度，从M*N到M+N</li>
</ul>
</li>
</ul>
</li>
<li><p>树形结构目录</p>
<ul>
<li>路径名<ul>
<li>“..”是父目录</li>
<li>“/”是根目录</li>
<li>区别绝对路径和相对路径（../…/…/1/2/3/）<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>有向无循环图（DAG）</p>
</li>
<li><p>利用符号链接实现文件共享</p>
<ul>
<li>实际上就是“快捷方式”<h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3></li>
</ul>
</li>
</ul>
<p><img src="https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" alt="picture"></p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="http://yoursite.com/2019/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="ck3lclaae0002qkuy71fd15uz" class="article-share-link">Share</a>-->
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </h1>
  

        <a href="/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2019-11-30T09:02:11.092Z" itemprop="datePublished">2019-11-30</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="第一章：数据结构的"><a href="#第一章：数据结构的" class="headerlink" title="第一章：数据结构的"></a>第一章：数据结构的</h2><p>基本概念</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3></li>
<li>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的</li>
<li>数据的逻辑结构分为线性结构和非线性结构<ul>
<li>集合 结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。 类似于数学上的集合</li>
<li>线性结构 结构中的数据元素之间只存在一对一的关系。比如排队</li>
<li>树形结构 结构中的数据元素之间存在一对多的关系。比如家族族谱</li>
<li>图状结构或网状结构 结构中的数据元素之间存在多对多的关系。 比如地图<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3></li>
</ul>
</li>
<li>存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。<ul>
<li>顺序存储：存储的物理位置相邻。（p.s. 物理位置即信息在计算机中的位置。）</li>
<li>链接存储：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素。</li>
<li>索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。</li>
<li>散列存储：通过关键字直接计算出元素的物理地址（以后详解）。<h3 id="算法的五个特征"><a href="#算法的五个特征" class="headerlink" title="算法的五个特征"></a>算法的五个特征</h3></li>
</ul>
</li>
<li>1，有穷性：有限步之后结束</li>
<li>2，确定性：不存在二义性，即没有歧义</li>
<li>3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。</li>
<li>4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。</li>
<li>5，输出：一至多个程序输出结果。<h3 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h3></li>
<li>时间复杂度：<ul>
<li>• 它用来衡量算法随着问题规模增大，算法执行时间增长的快慢；</li>
<li>• 是问题规模的函数：T(n)是时间规模函数 时间复杂度主要分析T(n)的数量级</li>
<li>• T(n)=O(f(n)) f(n)是算法中基本运算的频度 一般我们考虑最坏情况下的时间复杂度</li>
</ul>
</li>
<li>空间复杂度：<ul>
<li>• 它用来衡量算法随着问题规模增大，算法所需空间的快慢；</li>
<li>• 是问题规模的函数：S(n)=O(g(n)) ；算法所需空间的增长率和g(n)的增长率相同。<h3 id="概要-复杂度计算为重点"><a href="#概要-复杂度计算为重点" class="headerlink" title="概要: 复杂度计算为重点"></a>概要: 复杂度计算为重点</h3></li>
</ul>
</li>
<li>常用的时间复杂度大小关系：</li>
<li>复杂度如何计算<ul>
<li>时间复杂度计算（单个循环体）<ul>
<li>直接关注循环体的执行次数，设为k </li>
</ul>
</li>
<li>时间复杂度计算（多个循环体）<ul>
<li>两个运算规则：乘法规则，加法规则。<h2 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h2><h3 id="线性表的逻辑结构"><a href="#线性表的逻辑结构" class="headerlink" title="线性表的逻辑结构"></a>线性表的逻辑结构</h3></li>
</ul>
</li>
</ul>
</li>
<li>定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。其中n为表长。当n=0时 线性表是一个空表</li>
<li>特点：线性表中第一个元素称为表头元素；最后一个元素称为表尾元素。<br>除第一个元素外，每个元素有且仅有一个直接前驱。<br>除最后一个元素外，每个元素有且仅有一个直接后继。<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3></li>
<li>线性表的顺序存储又称为顺序表。<br>它是用一组地址连续的存储单元（比如C语言里面的数组），依次存储线性表中的数据元素，从而使得逻<br>辑上相邻的两个元素在物理位置上也相邻。</li>
<li>建立顺序表的三个属性: </li>
</ul>
<p>1.存储空间的起始位置（数组名data）<br>2.顺序表最大存储容量（MaxSize）<br>3.顺序表当前的长度（length）</p>
<ul>
<li>其实数组还可以动态分配空间，存储数组的空间是在程序执行过程中通过动态存储分配语句分配</li>
<li>总结：<ul>
<li>1.顺序表最主要的特点是随机访问（C语言中基于数组），即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。</li>
<li>2.顺序表的存储密度高，每个结点只存储数据元素。无需给表中元素花费空间建立它们之间的逻辑关系（因为物理位置相邻特性决定）</li>
<li>3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。<h3 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h3></li>
</ul>
</li>
<li>1.插入<ul>
<li>算法思路：<ul>
<li>1.判断i的值是否正确</li>
<li>2.判断表长是否超过数组长度</li>
<li>3.从后向前到第i个位置，分别将这些元素都向后移动一位</li>
<li>4.将该元素插入位置i 并修改表长</li>
</ul>
</li>
<li>代码</li>
<li>分析：<ul>
<li>最好情况：在表尾插入（即i=n+1），元素后移语句将不执行，时间复杂度为O(1)。</li>
<li>最坏情况：在表头插入（即i=1），元素后移语句将执行<br>n次，时间复杂度为O(n)。</li>
<li>平均情况：假设pi（pi=1/(n+1) ）是在第i个位置上插入<br>一个结点的概率，则在长度为n的线性表中插入一个结<br>点时所需移动结点的平均次数为</li>
</ul>
</li>
</ul>
</li>
<li>2.删除<ul>
<li>算法思路：<ul>
<li>1.判断i的值是否正确</li>
<li>2.取删除的元素</li>
<li>3.将被删元素后面的所有元素都依次向前移动一位</li>
<li>4.修改表长</li>
</ul>
</li>
<li>代码</li>
<li>分析<ul>
<li>最好情况：删除表尾元素（即i=n），无须移动元素，时间复杂度为O(1)。</li>
<li>最坏情况：删除表头元素（即i=1），需要移动除第一个元素外的所有元素，时间复杂度为O(n)。</li>
<li>平均情况：假设pi(pi=1/n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时所需移动结点的平均次数为<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3></li>
</ul>
</li>
</ul>
</li>
<li>线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。</li>
<li>头结点和头指针的区别？<ul>
<li>不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点链表中的第一个结点，结点内通常不存储信息</li>
</ul>
</li>
<li>为什么要设置头结点？<ul>
<li>1.处理操作起来方便 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了</li>
<li>2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了。<h3 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h3></li>
</ul>
</li>
<li>1.头插法建立单链表：<ul>
<li>建立新的结点分配内存空间，将新结点插入到当前链表的表头</li>
<li>代码</li>
</ul>
</li>
<li>2.尾插法建立单链表：<ul>
<li>建立新的结点分配内存空间，将新结点插入到当前链表的表尾</li>
<li>代码</li>
</ul>
</li>
<li>3.按序号查找结点<ul>
<li>在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止,否则返回最后一个结点指针域NULL。</li>
<li>代码</li>
</ul>
</li>
<li>4.按值查找结点<ul>
<li>从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。</li>
<li>代码</li>
</ul>
</li>
<li>5．插入<ul>
<li>插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i−1个结点，再在其后插入新结点。</li>
<li>算法思路：</li>
</ul>
</li>
</ul>
<p>1.取指向插入位置的前驱结点的指针<br>① p=GetElem(L,i-1);<br>2.令新结点<em>s的指针域指向</em>p的后继结点<br>② s-&gt;next=p-&gt;next;<br>3.令结点<em>p的指针域指向新插入的结点</em>s<br>③ p-&gt;next=s; </p>
<ul>
<li>6．删除<ul>
<li>删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i−1个结点，即被删结点的前驱结点，再将其删除。</li>
<li>算法思路：</li>
</ul>
</li>
</ul>
<p>1.取指向删除位置的前驱结点的指针 p=GetElem(L,i-1);<br>2.取指向删除位置的指针 q=p-&gt;next;<br>3.p指向结点的后继指向被删除结点的后继 p-&gt;next=q-&gt;next<br>4.释放删除结点 free(q);</p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><ul>
<li>定义</li>
<li>1.插入：(方法不唯一)<br>① s-&gt;next=p-&gt;next;<br>② p-&gt;next-&gt;prior=s;<br>③ s-&gt;prior=p;<br>④ p-&gt;next=s;</li>
<li>2.删除：<br>① p-&gt;next=q-&gt;next;<br>② q-&gt;next-&gt;prior=p;<br>③ free(q);</li>
</ul>
<h3 id="循环链表-amp-amp-静态链表"><a href="#循环链表-amp-amp-静态链表" class="headerlink" title="循环链表&amp;&amp;静态链表"></a>循环链表&amp;&amp;静态链表</h3><ul>
<li>循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</li>
<li>循环双链表：类比循环单链表，循环双链表链表区别于双链表就是首尾结点构成环<ul>
<li>当循环双链表为空表时，其头结点的prior域和next域都等于Head。</li>
</ul>
</li>
<li>静态链表：静态链表是用数组来描述线性表的链式存储结构。<ul>
<li>数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。链表最后一个元素的指针域值为-1。</li>
<li>例子<h2 id="第三章：栈和队列"><a href="#第三章：栈和队列" class="headerlink" title="第三章：栈和队列"></a>第三章：栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3></li>
</ul>
</li>
<li>栈（Stack）：只允许在一端进行插入或删除操作的线性表。</li>
<li>栈顶（Top）：线性表允许进行插入和删除的那一端。</li>
<li>栈底（Bottom）：固定的，不允许进行插入和删除的另一端</li>
<li>特点：</li>
</ul>
<p>1.栈是受限的线性表，所以自然具有线性关<br>系。<br>2.栈中元素后进去的必然先出来，即后进先出<br>LIFO（Last In First Out）<br>    * 栈中元素后进<br>去的必然先出<br>来，即后进先<br>出LIFO（Last In<br>First Out）</p>
<ul>
<li>顺序栈<ul>
<li>栈是线性表的特例，那栈的顺序存储也是线性表顺序存储的简化。栈的顺序存储结构也叫作顺序栈。</li>
<li>顺序栈的操作<ul>
<li>1.判空：</li>
<li>2.进栈：</li>
<li>3.出栈：</li>
<li>4.读取栈顶元素：</li>
</ul>
</li>
</ul>
</li>
<li>共享栈<ul>
<li>顺序栈的存储空间大小需要事先开辟好，很多时候对每个栈各自单独开辟存储空间的利用率不如将各个栈的存储空间共享</li>
<li>示意图</li>
<li>共享栈的结构</li>
<li>共享栈的操作：（进栈）</li>
</ul>
</li>
<li>链式栈<ul>
<li>栈是线性表的特例，线性表的存储结构还有链式存储结构，所以也可以用链表的方式来实现栈。栈的链式存储结构也叫作链栈。</li>
<li>特点</li>
</ul>
</li>
</ul>
<p>1.链栈一般不存在栈满的情况。<br>2.空栈的判定条件通常定为top==NULL；<br>    * 结构<br>    * 链式栈的操作<br>        * 1.进栈<br>        * 2.出栈</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li><p>队列是只允许在一端进行插入，而在另一端进行删除的线性表</p>
</li>
<li><p>队头（Front）：允许删除的一端，又称为队首。</p>
</li>
<li><p>队尾（Rear）： 允许插入的一端。</p>
</li>
<li><p>先进入队列的元素必然先离开队列，即先进先出（First In First Out）简称FIFO</p>
</li>
<li><p>顺序队列</p>
<ul>
<li>用数组来实现队列，可以将队首放在数组下标为0的位置。</li>
</ul>
</li>
<li><p>循环队列</p>
<ul>
<li>把数组“掰弯”，形成一个环。Rear指针到了下标为4的位置还能继续指回到下标为0的地方。这样首尾相连的顺序存储的队列就叫循环队列</li>
<li>入队：rear=(rear+1)%MaxSize</li>
<li>出队：front=(front+1)%MaxSize</li>
<li>循环队列的操作<ul>
<li>1.入队：</li>
<li>2.出队：</li>
</ul>
</li>
<li>概要: 那如何分辨队列是空还是满呢？<ul>
<li>方法一：设置标志位flag，当flag=0且rear等于front时为队列空，当flag=1且rear等于front时为队列满。</li>
<li>方法二：我们把front=rear仅作为队空的判定条件。当队列满的时候，令数组中仍然保留一个空余单元。我们认为这种情况就是队列满了。</li>
</ul>
</li>
</ul>
</li>
<li><p>链式队列</p>
<ul>
<li><p>队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素。</p>
</li>
<li><p>为了方便操作，我们分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向尾结点。</p>
</li>
<li><p>链式队列的操作</p>
<ul>
<li><p>1.入队：我们知道队列只能从队尾插入元素，队头删除元素。于是入队就是在队尾指针进行插入结点操作。链队的插入操作和单链表的插入操作是一致的。</p>
</li>
<li><p>2.出队：出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>双端队列</p>
<ul>
<li>双端队列是指允许两端都可以进行入队和出队操作的队列<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3></li>
</ul>
</li>
<li><p>1、括号匹配：假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的。</p>
<ul>
<li><p>算法思想：若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的。</p>
</li>
<li><p>代码</p>
</li>
</ul>
</li>
<li><p>2、表达式求值：</p>
<ul>
<li></li>
<li>规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将运算结果进栈，直到最终获得结果。</li>
</ul>
</li>
<li><p>3、递归：</p>
<ul>
<li>要理解递归，你要先理解递归，直到你能理解递归。<br>如果在一个函数、过程或数据结构的定义中又应用了它自身，那么这个函数、过程或数据结构称为是递归定义的，简称递归。递归最重要的是递归式和递归边界。</li>
<li>1.阶乘<ul>
<li>时间复杂度：O(NlogN)</li>
</ul>
</li>
<li>2.斐波那契数列<ul>
<li>时间复杂度   O(2^n)</li>
</ul>
</li>
</ul>
</li>
<li><p>概要: 如何将中缀表达式转换成后缀表达式？</p>
<ul>
<li>1.按运算符优先级对所有运算符和它的运算数加括号。(原本的括号不用加)</li>
<li>2.把运算符移到对应的括号后。</li>
<li>3.去掉括号。</li>
<li>例子<h2 id="第四章：树"><a href="#第四章：树" class="headerlink" title="第四章：树"></a>第四章：树</h2><h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3></li>
</ul>
</li>
<li><p>树是递归定义的结构</p>
</li>
<li><p>结点</p>
<ul>
<li>根节点：树只有一个根结点</li>
<li>结点的度：结点拥有的子树的数量<ul>
<li>度为0：叶子结点或者终端结点</li>
<li>度不为0：分支结点或者非终端结点<ul>
<li>分支结点除去根结点也称为内部结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>树的度：树中所有结点的度数的最大值</p>
</li>
<li><p>结点关系</p>
<ul>
<li>祖先结点<ul>
<li>根结点到该结点的唯一路径的任意结点</li>
</ul>
</li>
<li>子孙结点</li>
<li>双亲结点<ul>
<li>根结点到该结点的唯一路径上最接近该结点的结点</li>
</ul>
</li>
<li>孩子结点</li>
<li>兄弟结点<ul>
<li>有相同双亲结点的结点</li>
</ul>
</li>
</ul>
</li>
<li><p>层次，高度，深度，树的高度</p>
<ul>
<li>层次：根为第一层，它的孩子为第二层，以此类推</li>
<li>结点的深度：根结点开始自顶向下累加</li>
<li>结点的高度：叶节点开始自底向上累加</li>
<li>树的高度（深度）：树中结点的最大层数</li>
</ul>
</li>
<li><p>树的性质</p>
<ul>
<li>1.树中的结点数等于所有结点的度数加1。<ul>
<li>证明：不难想象，除根结点以外，每个结点有且仅有一个指向它的前驱结点。也就是说每个结点和指向它的分支一一对应。<br>假设树中一共有b个分支，那么除了根结点，整个树就包含有b个结点，所以整个树的结点数就是这b个结点加上根结点，设为n，则n=b+1。而分支数b也就是所有结点的度数，证毕。</li>
</ul>
</li>
<li>2.度为m的树中第i层上至多有m^(i−1)个结点（i≥1）。<ul>
<li>证明：（数学归纳法）<br>首先考虑i=1的情况：第一层只有根结点，即一个结点，i=1带入式子满足。<br>假设第i-1层满足这个性质，第i-1层最多有m i-2个结点。<br>……… ……….<br>i-1层<br>………<br>又因为树的度为m,所以对于第i-1层的每个结点，最多<br>有m个孩子结点。所以第i层的结点数最多是i-1层的m<br>倍，所以第i层上最多有m ^(i-1)个结点。</li>
</ul>
</li>
<li>3.高度为h的m叉树至多有(m^h-1)/(m-1)个结点</li>
<li>4.具有n个结点的m叉树的最小高度为logm(n(m-1)+1) <h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3></li>
</ul>
</li>
<li><p>顺序存储结构</p>
<ul>
<li>双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置。</li>
</ul>
</li>
<li><p>链式存储结构</p>
<ul>
<li><p>孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；<br>如果是叶子结点，那这个结点的孩子单链表就是空的；<br>然后n个单链表的的头指针又存储在一个顺序表（数组）中。</p>
</li>
<li><p>孩子兄弟表示法：顾名思义就是要存储孩子和孩子结点的兄弟，具体来说，就是设置两个指针，分别指向该结<br>点的第一个孩子结点和这个孩子结点的右兄弟结点。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3></li>
</ul>
</li>
<li><p>定义</p>
<ul>
<li>二叉树是n（n≥0）个结点的有限集合：<br>① 或者为空二叉树，即n=0。<br>② 或者由一个根结点和两个互不相交的被称为根的左子树<br>和右子树组成。左子树和右子树又分别是一棵二叉树。 <ul>
<li>1.每个结点最多有两棵子树。</li>
<li>2.左右子树有顺序</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉树的五种基本形态：</p>
<ul>
<li>1.空树</li>
<li>2.只有一个根结点</li>
<li>3.根结点只有左子树</li>
<li>4.根结点只有右子树</li>
<li>5.根结点既有左子树又有右子树</li>
</ul>
</li>
<li><p>特殊二叉树</p>
<ul>
<li>1.斜树</li>
<li>2.满二叉树:</li>
<li>3.完全二叉树</li>
</ul>
</li>
<li><p>二叉树的性质</p>
<ul>
<li>1.非空二叉树上叶子结点数等于度为2的结点数加1</li>
<li>2.非空二叉树上第K层上至多有2^k−1个结点（K≥1）</li>
<li>3.高度为H的二叉树至多有2^H-1个结点（H≥1）</li>
<li>4.具有N个（N&gt;0）结点的完全二叉树的高度为 [log2(N+1)]或[log2N] +1。<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3></li>
</ul>
</li>
<li><p>顺序存储</p>
<ul>
<li>二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。</li>
</ul>
</li>
<li><p>链式存储</p>
<ul>
<li>二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子。<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3></li>
</ul>
</li>
<li><p>先序遍历：<br>1）访问根结点；<br>2）先序遍历左子树；<br>3）先序遍历右子树。</p>
<ul>
<li>递归</li>
<li>非递归</li>
</ul>
</li>
<li><p>中序遍历：<br>1）中序遍历左子树；<br>2）访问根结点；<br>3）中序遍历右子树。</p>
<ul>
<li>递归</li>
<li>非递归</li>
</ul>
</li>
<li><p>后序遍历：<br>1）后序遍历左子树；<br>2）后序遍历右子树；<br>3）访问根结点。</p>
<ul>
<li>递归</li>
<li>非递归</li>
</ul>
</li>
<li><p>层次遍历：<br>若树为空，则什么都不做直接返回。<br>否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p>
</li>
</ul>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><ul>
<li><p>N个结点的二叉链表，每个结点都有指向左右孩子的<br>结点指针，所以一共有2N个指针，而N个结点的二叉<br>树一共有N-1条分支，也就是说存在2N-(N-1)=N+1个空指针。比如左图二叉树中有6个结点，那么就有7个空<br>指针。</p>
</li>
<li><p>大量的空余指针能否利用起来？</p>
<ul>
<li>指向前驱和后继的指针称为线索，加上线索的二叉链表就称为线索链表，相应的二叉树就称为线索二叉树</li>
<li>对二叉树以某种次序遍历使其变为线索二叉树的过程就叫做线索化<h3 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3></li>
</ul>
</li>
<li><p>算法的描述如下：<br>1）将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。<br>2）构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值<br>置为左、右子树上根结点的权值之和。<br>3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。<br>4）重复步骤2）和3），直至F中只剩下一棵树为止。</p>
</li>
</ul>
<h2 id="第五章：图"><a href="#第五章：图" class="headerlink" title="第五章：图"></a>第五章：图</h2><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><ul>
<li>定义：<br>树是N（N≥0）个结点的有限集合，N=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：<br>1）有且仅有一个特定的称为根的结点。<br>2）当N&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集合T1，T2，…，Tm，其中每一个集合本身又是一棵树，并且称为根结点的子树。<ul>
<li>图G由顶点集V和边集E组成，记为G=(V，E)<ul>
<li>V(G)表示图G中顶点的有限非空集。<br>用|V|表示图G中顶点的个数，也称为图G的阶</li>
<li>E(G)表示图G中顶点之间的关系（边）集合。<br>用|E|表示图G中边的条数。</li>
</ul>
</li>
</ul>
</li>
<li>分类<ul>
<li>有向图<ul>
<li>有向边（弧）的有限集合<ul>
<li>弧是顶点的有序对</li>
<li>&lt;v,w&gt;</li>
<li>v是弧尾，w是弧头</li>
<li>v邻接到w或w邻接自v</li>
</ul>
</li>
</ul>
</li>
<li>无向图<ul>
<li>无向边的有限集合<ul>
<li>边是顶点的无序对</li>
<li>（v,w）</li>
<li>（v,w）=(w,v)</li>
<li>w，v互为邻接点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>简单图<ul>
<li>1.不存在顶点到自身的边</li>
<li>2.同一条边不重复出现</li>
</ul>
</li>
<li>多重图<ul>
<li>若图G中某两个结点之间的边数多于一条，又允许顶点通过通过同一个边和自己关联</li>
</ul>
</li>
<li>完全图<ul>
<li>无向完全图<ul>
<li>如果任意两个顶点之间都存在边</li>
</ul>
</li>
<li>有向完全图<ul>
<li>如果任意两个顶点之间都存在方向相反的两条弧</li>
</ul>
</li>
</ul>
</li>
<li>子图</li>
<li>连通图：图中任意两个顶点都是连通的</li>
<li>连通分量：无向图中的极大连通子图<ul>
<li>连通<ul>
<li>顶点A到顶点B有路径</li>
</ul>
</li>
<li>极大<ul>
<li>1.顶点足够多</li>
<li>2.极大连通子图包含这些依附这些顶点的所有边</li>
</ul>
</li>
<li>结论1:如果一个图有n个顶点，并且有小于n-1条边，则此图必是非连通图。</li>
<li>概要: 找连通分量的方法：<br>从选取一个顶点开始，以这个顶点作为一个子图，然后逐个添加与这个子图相连的顶点和边直到所有相连的顶点都加入该子图</li>
</ul>
</li>
<li>强连通：顶点V到顶点W和顶点W到顶点V都有路径</li>
<li>强连通图：图中任一对顶点都是强连通的</li>
<li>连通图的生成树：包含图中全部n个顶点，但是只有n-1条边的极小连通子图<ul>
<li>结论2:生成树去掉一条边则变成非连通图，加上一条边就会形成回路。</li>
</ul>
</li>
<li>度：以该顶点为一个端点的边数目<ul>
<li>无向图中顶点V的度是指依附于该顶点的边的条数，记为TD(v)</li>
<li>有向图中顶点V的度分为出度和入度<ul>
<li>入度（ID）是以顶点v为终点的有向边的数目</li>
<li>出度（OD）是以顶点V为起点的有向边的数目</li>
</ul>
</li>
</ul>
</li>
<li>简单路径和简单回路：顶点不重复出现的路径称为简单路径。对于回路，除了第一个和最后一个顶点其余顶点不重复出现的回路称为简单回路</li>
<li>权和网：图中每条边考研赋予一定意义的数值，这个数值叫做这条边的权，有权值得图称为带权图，也叫做网</li>
<li>路径和路径长度：顶点p到q之间的路径是指顶点序列怕保存的，p,a,b,c,d,……q。路径上边的数目就是路径长度</li>
<li>回路（环）：第一个和最后一个顶点相同的路径称为回路或者环</li>
<li>距离：从顶点u到v的最短路径长度。不存在路径则为无穷<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3></li>
<li>邻接矩阵（顺序存储）</li>
<li>邻接表（链式存储）<ul>
<li>十字链表（有向图）</li>
<li>邻接多重表（无向图）<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3></li>
</ul>
</li>
<li>深度优先遍历<ul>
<li>深度优先搜索(DFS:Depth-First-Search):深度优先搜索类似于树的先序遍历算法<ul>
<li>空间复杂度：由于DFS是一个递归算法，递归是需要一个工作栈来辅助工作，最多需要图中所有顶点进栈，所以时间复杂度为O(|V|)</li>
<li>时间复杂度：1)邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|),访问顶点时间为O(|V|),所以总的时间复杂度为O(|V|+|E|)<pre><code>2)邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|),对每个顶点都进行查找，所以总的时间复杂度为O(|V|2)</code></pre></li>
</ul>
</li>
</ul>
</li>
<li>广度优先遍历<ul>
<li>广度优先搜索(BFS:Breadth-First-Search):广度优先搜索类似于树的层序遍历算法<ul>
<li>空间复杂度：BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度。    </li>
<li>时间复杂度：<br>1)邻接表：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)<br>2)邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为O(|V|),所以总的时间复杂度为O(|V|2)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><ul>
<li>最小生成树<ul>
<li>普利姆（Prlm）<ul>
<li>①从图中找第一个起始顶点v0，作为生成树的第一个顶点，然后从这个顶点到其他顶点的所有边中选一条权值最小的边。然后把这条边的另一个顶点v和这条边加入到生成树中。</li>
<li>②对剩下的其他所有顶点，分别检查这些顶点与顶点v的权值是否比这些顶点在lowcost数组中对应的权值小，如果更小，则用较小的权值更新lowcost数组。</li>
<li>③从更新后的lowcost数组中继续挑选权值最小而且不在生成树中的边，然后加入到生成树。</li>
<li>④反复执行②③直到所有所有顶点都加入到生成树中。</li>
<li>概要:  <ul>
<li>双重循环，外层循环次数为n-1，内层并列的两个循环次数都是n。故普利姆算法时间复杂度为O(n2)<br>而且时间复杂度只和n有关，所以适合稠密图</li>
</ul>
</li>
</ul>
</li>
<li>克鲁斯卡尔（Kruskal）<ul>
<li>将图中边按照权值从小到大排列，然后从最小的边开始扫描，设置一个边的集合来记录，如果该边并入不构成回路的话，则将该边并入当前生成树。直到所有的边都检测完为止。</li>
<li>概要:  <ul>
<li></li>
<li></li>
<li>概要: 克鲁斯卡尔算法操作分为对边的权值排序部分和一个单重for循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上。排序和图中边的数量有关系，所以适合稀疏图</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>最短路径<ul>
<li>迪杰斯特拉<ul>
<li>一个源点到其余顶点的最短路径<ul>
<li>该算法设置一个集合S记录已求得的最短路径的顶点，可用一个数组s[]来实现，初始化为0，当s[vi]=1时表示将顶点vi放入S中，初始时把源点v0放入S中。此外，在构造过程中还设置了两个辅助数组：<br>dist[]：记录了从源点v0到其他各顶点当前的最短路径长度，dist[i]初值为arcs[v0][i]。<br>path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点v0到顶点vi的最短路径。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>假设从顶点0出发，也就是顶点0为源点，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边&lt;i，j&gt;的权值，若不存在有向边&lt;i，j&gt;，则arcs[i][j]为∞。Dijkstra算法的步骤如下：<br>1）初始化：集合S初始为{0}，dist[]的初始值dist[i]=arcs[0][i]，i=1，2，…，n-1。<br>2）找出dist[]中的最小值dist[j]，将顶点j加入集合S，即修改s[vj]=1。<br>3）修改从v0出发到集合V-S上任一顶点vk可达的最短路径长度：如果dist[j] + arcs[j][k]&lt; dist[k]，则令dist[k]=dist[j] + arcs[j][k]。另外更新path[k]=j(也就是顶点j加入集合之后如果有新的路径使得到顶点k路径变短的话就将到顶点k的路径长度修改成较短的)<br>4）重复2）～3）操作共n-1次，直到所有的顶点都包含在S中。<br>    * 弗洛伊德<br>        * 所有顶点到所有顶点的最短路径<br>            * 算法思想：<br>递推产生一个n阶方阵序列A(−1)，A(0)，…，A(k)，…，A(n−1)<br>其中A(k)[i][j]表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点vi和vj，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k=0，1，…，n-1)作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径<br>    * 非带权图<br>        * 两点之间经过边数最少的路径<br>    * 带权图<br>        * 两点之间经过的边上权值之和最小的路径</p>
<ul>
<li><p>拓扑排序</p>
<ul>
<li><p>AOV</p>
<ul>
<li>如果我们把每个环节看成图中一个顶点，在这样一个有向图中，用顶点表示活动，用弧表示活动之间的优先关系，那么这样的有向图称为AOV网(Activity On Vertex)</li>
</ul>
</li>
<li><p>拓扑排序就是对一个有向图构造拓扑序列的过程，构造会有两种结果：<br>如果此图全部顶点都被输出了，说明它是不存在回路的AOV网；<br>如果没有输出全部顶点，则说明这个图存在回路，不是AOV网。</p>
</li>
<li><p>拓扑排序算法：<br>从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧。重复这个步骤直到输出图中全部顶点，或者找不到入度为0的顶点为止。</p>
</li>
</ul>
</li>
<li><p>关键路径</p>
<ul>
<li>AOE(Activity On Edge):在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。</li>
</ul>
</li>
</ul>
<h2 id="第六章：查找"><a href="#第六章：查找" class="headerlink" title="第六章：查找"></a>第六章：查找</h2><h3 id="查找的基本概念和顺序查找"><a href="#查找的基本概念和顺序查找" class="headerlink" title="查找的基本概念和顺序查找"></a>查找的基本概念和顺序查找</h3><ul>
<li>查找定义：在数据集合中寻找满足某种条件的数据元素的过程称为查找</li>
<li>关键字：数据元素中某个可以以唯一标识该元素的数据项</li>
<li>平均查找长度（ASL：Average Search Length）:在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值</li>
<li>顺序查找(线性查找)，主要用于在线性表中进行查找。从查找表的一端开始，顺序扫描查找表，依次将扫描到的关键字和待查找的值key进行比较。如果相等，则查找成功。如果扫描结束仍然没有发现相等的数据元素，则查找失败。<ul>
<li>1</li>
<li>2</li>
<li>3 </li>
<li>4</li>
<li>时间复杂度为O(n)<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3></li>
</ul>
</li>
<li>算法思路：<ul>
<li>首先将给定值key与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分中。然后在缩小的范围内继续进行同样的查找，如此重复直到找到为止，或者确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。</li>
</ul>
</li>
<li>折半查找分析<ul>
<li>折半查找判定树<ul>
<li>对于折半查找，查找的比较次数就是从根结点到该结点经历的结点数</li>
<li>时间复杂度为O(logn)</li>
<li>概要: 具有N个（N&gt;0）结点的完全二叉树的高度为 [log2(N+1)] 或 [log2N] +1。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><ul>
<li>分块查找又称为索引顺序查找</li>
<li>分块查找思想：<ul>
<li>①确定待查找值在哪个块（折半查找）</li>
</ul>
</li>
</ul>
<p>②在确定的块中查找待查找值（顺序查找）</p>
<ul>
<li><p>分块查找分析</p>
<ul>
<li>由于分块查找实际是进行两次查找，所以整个算法的平均查找长度是两次查找的平均查找长度之和。<br>即ASL分块=ASL折半+ASL顺序<ul>
<li><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>二叉排序树(Binary Search Tree 也叫二叉搜索树)或者是一棵空树，或者是具有以下性质的二叉树<br>①若左子树不空，则左子树上所有结点的值均小于它的根结点的值。<br>②若右子树不空，则右子树上所有结点的值均大于它的根结点的值。<br>③它的左右子树也是一棵二叉排序树。</p>
</li>
<li><p>算法思想</p>
<ul>
<li>由于二叉排序树的特点(左子树&lt;根结点&lt;右子树),所以每次查找一个关键字，需要先和根结点进行比较：<br>如果这个关键字小于根结点的值，则再到这个根结点的左子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。<br>如果这个关键字大于根结点的值，则再到这个根结点的右子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。<ul>
<li>查找关键字代码<ul>
<li>1 </li>
<li>2</li>
</ul>
</li>
<li>插入关键字代码<ul>
<li>1)空树：直接插入新结点返回成功<br>2)树不空：检查是否存在关键字重复的结点：<br>①存在：返回插入失败<br>②不存在：检查根结点的值和待插入关键字值的大小关系递归插入左右子树</li>
<li></li>
</ul>
</li>
<li>构造代码<ul>
<li></li>
</ul>
</li>
<li>删除结点<ul>
<li>①删除的是叶子结点<ul>
<li>方法：直接删去该结点即可</li>
</ul>
</li>
<li>②删除的是仅有左子树或者右子树的结点<ul>
<li>方法：“子承父业”</li>
</ul>
</li>
<li>③删除的是左右子树都有的结点<ul>
<li>仿照②类型，先将一个孩子“继承父业”，另一个孩子“归顺”于这个孩子<br>方法：找到待删除结点的直接前驱或者直接后继结点，用该结点来替换待删除结点，再删除该结点。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉排序树分析</p>
<ul>
<li>查找时间复杂度是O(n)</li>
</ul>
</li>
<li><p>概要: “左小右大”</p>
<h3 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h3></li>
<li><p>平衡二叉树(AVL树)是特殊的二叉排序树，特殊的地方在于左右子树的高度之差绝对值不超过1，而且左右子树又是一棵平衡二叉树。</p>
</li>
<li><p>平衡因子</p>
<ul>
<li>定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是−1、0或1。</li>
</ul>
</li>
<li><p>平衡调整</p>
<ul>
<li><p>平衡二叉树的建立过程和二叉排序树的建立过程是相似的，都是从一棵空树开始陆续插入结点。不同的地方在于对于平衡二叉树的建立过程中，由于插入结点可能会破坏结点的平衡性，所以需要进行平衡调整。</p>
<ul>
<li>LL调整(左孩子的左子树上插入结点导致)<ul>
<li>最小不平衡子树根结点的平衡因子为2&gt;0<br>它的左孩子结点平衡因子为1&gt;0<br>两个都大于0，所以直接右旋就可以调整</li>
<li>概要: “正则右旋”</li>
</ul>
</li>
<li>RR调整(右孩子的右子树上插入结点导致)<ul>
<li>最小不平衡子树根结点的平衡因子为-2&lt;0<br>它的右孩子结点平衡因子为-1&lt;0<br>两个都小于0，所以直接左旋就可以调整</li>
<li>概要: “负则左旋”</li>
</ul>
</li>
<li>LR调整(左孩子的右子树上插入结点导致)</li>
<li>RL调整(右孩子的左子树上插入结点导致)</li>
<li>概要: 先局部转换为LL或RR，最后进行调整</li>
</ul>
</li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>含有n个结点平衡二叉树的最大深度为O(log2n)，因此，平衡二叉树的平均查找长度为O(log2n) <h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3></li>
</ul>
</li>
<li><p>2-3树</p>
<ul>
<li>2-3树是一种多路查找树：2和3的意思就是2-3树包含两种结点<ul>
<li>1)2结点包含一个元素和两个孩子(或者没有孩子)。<br>①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值<br>②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子</li>
<li>2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。(两个元素按大小顺序排列好)<br>①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。<br>②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子</li>
<li>3)2-3树所有叶子结点都在同一层次</li>
</ul>
</li>
</ul>
</li>
<li><p>2-3-4树</p>
<ul>
<li>2-3-4树也是一种多路查找树：2和3和4的意思就是2-3-4树包含三种结点<ul>
<li>1)2结点包含一个元素和两个孩子(或者没有孩子)。<br>①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值<br>②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子</li>
<li>2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。<br>①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。<br>②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子</li>
<li>3)4结点包含小中大三个元素和四个孩子(或者没有孩子)。<br>①左子树包含的元素小于该结点最小的元素值，第二个子树包含大于最小的元素值小于中间元素值的元素，第三个子树包含大于中间元素值小于最大元素值的元素，右子树包含的元素大于该结点最大的元素值。<br>②4结点要不有四个孩子，要不就没有孩子，不允许有一个或两个或三个孩子</li>
<li>4)2-3-4树所有叶子结点都在同一层次</li>
</ul>
</li>
</ul>
</li>
<li><p>B树</p>
<ul>
<li><p>B树也是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，我们把树中结点最大的孩子数目称为B树的阶。通常记为m。<br>一棵m阶B树或为空树，或为满足如下特性的m叉树：</p>
<ul>
<li>1）树中每个结点至多有m棵子树。（即至多含有m-1个关键字) (“两棵子树指针夹着一个关键字”)</li>
<li>2）若根结点不是终端结点，则至少有两棵子树。(至少一个关键字)</li>
<li>3）除根结点外的所有非叶结点至少有 ⌈m/2⌉棵子树。（即至少含有⌈m/2⌉-1个关键字）</li>
<li>4）所有非叶结点的结构如下：</li>
<li>5）所有的叶子结点出现在同一层次上，不带信息。(就像是折半查找判断树中查找失败的结点)</li>
</ul>
</li>
<li><p>1.B树的查找操作</p>
<ul>
<li>查找过程：①先让待查找关键字key和结点的中的关键字比较，如果等于其中某个关键字，则查找成功。<pre><code>②如果和所有关键字都不相等，则看key处在哪个范围内，然后去对应的指针所指向的子树中查找。
    Eg:如果Key比第一个关键字K1还小，则去P0指针所指向的子树中查找，如果比最后一个关键字Kn还大，则去Pn指针所指向的子树中查找。</code></pre></li>
</ul>
</li>
<li><p>2.B树的插入操作</p>
<ul>
<li>分裂的方法：取这个关键字数组中的中间关键字(⌈n/2⌉)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子。</li>
</ul>
</li>
<li><p>3.B树的删除操作</p>
<ul>
<li><p>B树中的删除操作与插入操作类似，但要稍微复杂些，要使得删除后的结点中的关键字个数≥⌈m/2⌉-1 ，因此将涉及结点的“合并”问题。由于删除的关键字位置不同，可以分为关键字在终端结点和不在终端结点上两种情况。</p>
<ul>
<li><p>1）如果删除的关键字在终端结点上（最底层非叶子结点）：<br>①结点内关键字数量大于⌈m/2⌉-1 ，这时删除这个关键字不会破坏B树的定义要求。所以直接删除。<br>②结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中存在关键字数量大于⌈m/2⌉-1 的结点，则去兄弟阶段中借关键字。<br>③结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中不存在关键字数量大于⌈m/2⌉-1 的结点，则需要进行结点合并。</p>
</li>
<li><p>2）如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上，再按照在终端结点     上的情况来分别考虑对应的方法。</p>
<ul>
<li>相邻关键字：对于不在终端结点上的关键字,它的相邻关键字是其左子树中值最大的关键字或者右子树中值最小的关键字。</li>
<li>第一种情况：存在关键字数量大于⌈m/2⌉-1 的左子树或者右子树，在对应子树上找到该关键字的相邻关键字，然后将相邻关键字替换待删除的关键字。</li>
<li>第二种情况：左右子树的关键字数量均等于⌈m/2⌉-1 ，则将这两个左右子树结点合并，然后删除待删除关键字。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B+树</p>
<ul>
<li>B+树是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构</li>
<li>m阶的B+树与m阶的B树的主要差异在于：<br>1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。<br>2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是 ⌈m/2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m/2⌉ -1≤n≤m-1（根结点：1≤n≤m-1）。<br>3）在B+树中，叶结点包含信息，所有非叶结点仅起到索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。<br>4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3></li>
</ul>
</li>
<li><p>散列表：根据给定的关键字来计算出关键字在表中的地址的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</p>
</li>
<li><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr。</p>
</li>
<li><p>散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”，这些发生碰撞的不同关键字称为同义词。</p>
</li>
<li><p>构造散列函数的tips：</p>
<ul>
<li>1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</li>
<li>2）散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生。</li>
<li>3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。</li>
</ul>
</li>
<li><p>1.常用Hash函数的构造方法：</p>
<ul>
<li>1.开放定址法：直接取关键字的某个线性函数值为散列地址，散列函数为H(key)=a×key+b。式中，a和b是常数。这种方法计算最简单，并且不会产生冲突</li>
<li>2.除留余数法：假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为H(key)=key % p<br>除留余数法的关键是选好p，使得每一个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性</li>
<li>3.数字分析法：设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合</li>
<li>4.平方取中法：顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。</li>
<li>5.折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。</li>
</ul>
</li>
<li><p>2.常用Hash函数的冲突处理办法：</p>
<ul>
<li>1.开放定址法：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。<ul>
<li>1）线性探测法：冲突发生时，顺序查看表中下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。</li>
<li>2）平方探测法：设发生冲突的地址为d,平方探测法得到的新的地址序列为d+12，d-12，d+22，d-22……<br>平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。</li>
<li>3）再散列法：又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H(Key)得到的地址发生冲突时，则利用第二个散列函数Hash2(Key)计算该关键字的地址增量。</li>
<li>4）伪随机序列法：当发生地址冲突时，地址增量为伪随机数序列，称为伪随机序列法。</li>
</ul>
</li>
<li>2.拉链法：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。</li>
<li>3.散列表的查找过程：类似于构造散列表，给定一个关键字Key。<br>先根据散列函数计算出其散列地址。然后检查散列地址位置有没有关键字。<br>   1)如果没有，表明该关键字不存在，返回查找失败。<br>   2)如果有，则检查该记录是否等于关键字。<pre><code>①如果等于关键字，返回查找成功。
②如果不等于，则按照给定的冲突处理办法来计算下一个散列地址，再用该地址去执行上述过程。</code></pre></li>
<li>4.散列表的查找性能：和装填因子有关。<ul>
<li></li>
<li>α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突的可能性越小<h2 id="第七章：排序"><a href="#第七章：排序" class="headerlink" title="第七章：排序"></a>第七章：排序</h2><h3 id="排序的基本知识"><a href="#排序的基本知识" class="headerlink" title="排序的基本知识"></a>排序的基本知识</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>定义：排序就是将原本无序的序列重新排列成有序的序列。</p>
</li>
<li><p>排序的稳定性</p>
<ul>
<li>如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi=keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。<h3 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h3></li>
</ul>
</li>
<li><p>直接插入排序</p>
<ul>
<li>直接插入排序：首先以一个元素为有序的序列，然后将后面的元素依次插入到有序的序列中合适的位置直到所有元素都插入有序序列。</li>
<li>时间复杂度为O(n)</li>
<li>直接插入排序是稳定性是稳定的。</li>
</ul>
</li>
<li><p>折半插入排序</p>
<ul>
<li>折半插入排序将比较和移动这两个操作分离出来，也就是先利用折半查找找到插入的位置，然后一次性移动元素，再插入该元素。</li>
<li>折半插入排序的时间复杂度为O(n^2)</li>
<li>稳定性：和直接插入排序稳定性相同，是稳定的。</li>
</ul>
</li>
<li><p>希尔排序</p>
<ul>
<li>希尔排序的基本思想：希尔排序本质上还是插入排序，只不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序。<ul>
<li>①先以增量5来分割序列，也就是下标为0,5,10,15…的关键字分成一组，下标为1,6,11,16..分成一组,然后对这些组分别进行直接插入排序，这就完成了一轮希尔排序。</li>
<li>②缩小增量(d1=n/2，di+1= [di/2]，比如10个数据序列，第一次增量d1=10/2=5,第二次增量d2= [d1/2]= [5/2]=2,并且最后一个增量等于1),所以第二轮以增量为2进行类似的排序过程。</li>
<li>③接下来的第三轮，第四轮…都是类似的过程，直到最后一轮以增量为1。此时就是前面所说的直接插入排序。</li>
<li>概要:  </li>
</ul>
</li>
<li>时间复杂度：…  希尔排序的时间复杂度约为O(n^1.3)    在最坏情况下希尔排序的时间复杂度为O(n^2)</li>
<li>空间复杂度：希尔排序的空间复杂度为O(1)</li>
<li>稳定性：不稳定，由于不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化。<h3 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h3></li>
</ul>
</li>
<li><p>冒泡排序</p>
<ul>
<li>假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置，……，这样最多做n-1趟冒泡就能把所有元素排好序。</li>
<li>空间复杂度：交换时开辟了存储空间来存储中间变量，所以空间复杂度为O(1)</li>
<li>时间复杂度</li>
<li>稳定性：当两个关键字相等，if判断条件不成立，所以不会发生数据移动。所以是稳定的。</li>
</ul>
</li>
<li><p>快速排序</p>
<ul>
<li>快速排序是一种基于分治法的排序方法。<br>每一趟快排选择序列中任一个元素作为枢轴(pivot)(通常选第一个元素)，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。<ul>
<li>1</li>
<li>2</li>
</ul>
</li>
<li>时间复杂度：<br>最好情况下时间复杂度为O(nlogn) ,待排序序列越无序，算法效率越高。<br>最坏情况下时间复杂度为O(n^2)，待排序序列越有序，算法效率越低。</li>
<li>空间复杂度：<br>由于快速排序是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。<br>最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn)<br>最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；</li>
<li>稳定性：快速排序是不稳定的，是因为存在交换关键字。<h3 id="选择类排序"><a href="#选择类排序" class="headerlink" title="选择类排序"></a>选择类排序</h3></li>
</ul>
</li>
<li><p>简单选择排序</p>
<ul>
<li></li>
<li>空间复杂度：需要额外的存储空间仅为交换元素时借助的中间变量，所以空间复杂度是O(1)</li>
<li>时间复杂度：<br>关键操作在于交换元素操作，整个算法由双重循环组成，外层循环从0到n-2一共n-2+1=n-1次，<br>对于第i层外层循环，内层循环执行n-1-(i+1)+1=n-i-1次。<pre><code>当i=0,内层循环执行n-1次，当i=n-2,内层循环执行1次，所以是一个等差数列求和,一共为(1+n-1)(n-1)/2=n(n-1)/2 ,所以时间复杂度为O(n^2)</code></pre></li>
<li>稳定性：不稳定   原因就在于交换部分会打破相对顺序</li>
</ul>
</li>
<li><p>堆排序</p>
<ul>
<li><p>什么是堆？</p>
<ul>
<li>堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。<ul>
<li>如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。</li>
<li>如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是堆排序？</p>
<ul>
<li><p>我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。</p>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li><p>时间复杂度：<br>堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆</p>
<p>堆排序的时间复杂度为O(n)+O(nlog2n)=O(nlog2n)</p>
</li>
<li><p>堆排序不稳定</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并，得到 ⌈n/2⌉个长度为2或1的有序表；再两两归并，……如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。</p>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li><p>例如：49 38 65 97 76 13 27</p>
<ul>
<li>①首先将整个序列的每个关键字看成一个单独的有序的子序列</li>
<li>②两两归并，49和38归并成{38 49} ，65和97归并成{65 97}，76和13归并成{13 76}，27没有归并对象</li>
<li>③两两归并，{38 49}和{65 97}归并成{38 49 65 97}，{13,76}和27归并成{13 27 76}</li>
<li>④两两归并，{38 49 65 97}和{13 27 76}归并成{13 27 38 49 65 76 97}</li>
</ul>
</li>
<li><p>时间复杂度：O(nlog2n)</p>
</li>
<li><p>空间复杂度:因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为n的存储空间，即空间复杂度为O(n)</p>
</li>
<li><p>稳定性：稳定</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3></li>
<li><p>基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。</p>
</li>
<li><p>例子：53, 3, 542, 748, 14, 214, 154, 63, 616</p>
<ul>
<li>补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616</li>
<li>桶实际是一个队列，先进先出(从桶的上面进，下面出)</li>
<li>关键字数量为n,关键字的位数为d,比如748 d=3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r=10</li>
</ul>
</li>
<li><p>空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O(r)</p>
</li>
<li><p>时间复杂度：需要进行关键字位数d次”分配”和”收集”，一次”分配”需要将n个关键字放进各个队列中，一次”收集”需要将r个桶都收集一遍。所以一次”分配”和一次”收集”时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。</p>
</li>
<li><p>稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。</p>
<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3></li>
<li><p>需要将待排序的记录存储在外存上，排序时再把数据一部分一部分的调入内存进行排序。在排序过程中需要多次进行内存和外存之间的交换，对外存文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序的方法就叫做外部排序。</p>
</li>
<li><p>如何得到初始的归并段</p>
<ul>
<li>置换选择排序：解决排序段放入内存的问题</li>
</ul>
</li>
<li><p>如何减少多个归并段的归并次数</p>
<ul>
<li>最佳归并树：最少的归并次数（I/O次数）</li>
</ul>
</li>
<li><p>如何每次m路归并快速得到最小的关键字</p>
<ul>
<li>败者树：减少比较次数</li>
</ul>
</li>
<li><p>概要: 内存容量无法容纳大量数据</p>
<h2 id="二叉树与树与森林"><a href="#二叉树与树与森林" class="headerlink" title="二叉树与树与森林"></a>二叉树与树与森林</h2><h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3></li>
<li><p>如何将一棵树转化成二叉树？</p>
<ul>
<li>树的孩子兄弟表示法与二叉树的二叉链表表示法都是用到两个指针<ul>
<li>将孩子兄弟表示法理解成二叉链表</li>
</ul>
</li>
<li>树转换成二叉树的手动模拟方法：<ul>
<li>①将同一结点的各个孩子用线串连起来</li>
<li>②将每个结点的子树分支，从左往右，除了第一个以外全部删除</li>
<li>概要: 例子</li>
</ul>
</li>
</ul>
</li>
<li><p>如何将一棵二叉树转化成树？</p>
<ul>
<li>二叉树转换成树的手动模拟方法：<ul>
<li>①将二叉树从上到下分层，并调节成水平方向。<br>(分层方法：每遇到左孩子则为一层)</li>
<li>②找到每一层的双亲结点，方法为它的上一层相连的那个结点就是双亲结点。<br>例如bcd这一层，与它相连的上一层结点即为a,所以bcd这三个结点的双亲结点都是a.</li>
<li>③将每一层结点和其双亲结点相连，同时删除该双亲结点各个孩子结点之间的联系。</li>
<li>概要: 例子<h3 id="森林与二叉树"><a href="#森林与二叉树" class="headerlink" title="森林与二叉树"></a>森林与二叉树</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>森林：森林是m（m≥0）棵互不相交的树的集合</p>
</li>
<li><p>如何将森林转换成二叉树？</p>
<ul>
<li>森林转换成树的手动模拟方法：<ul>
<li>①将森林中每棵树都转换成二叉树</li>
<li>②将第二棵树作为第一棵树的根结点的右子树，将第三棵树作为第二棵树的根结点的右子树..依次类推</li>
<li>概要: 例子</li>
</ul>
</li>
</ul>
</li>
<li><p>如何将二叉树转换成森林？</p>
<ul>
<li>二叉树转换成森林的手动模拟方法：<ul>
<li>反复断开二叉树根结点的右孩子的右子树指针，直到不存在根结点有右孩子的二叉树为止。</li>
<li>概要: 例子<h3 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>先序：先访问根结点，再访问根结点的每棵子树。           访问子树也是按照先序的要求</p>
</li>
<li><p>后序：先访问根结点的每棵子树，再访问根结点。           访问子树也是按照先序的要求</p>
</li>
<li><p>树的先序遍历等于它对应二叉树的先序遍历，后序遍历等于它对应的二叉树的中序遍历</p>
</li>
<li><p>概要: 例子</p>
</li>
</ul>
<p><img src="https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="picture"></p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="http://yoursite.com/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="ck3lcla9w0000qkuyhdes421v" class="article-share-link">Share</a>-->
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
    </h1>
  

        <a href="/2019/11/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-11-28T02:55:23.805Z" itemprop="datePublished">2019-11-28</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="头文件、名称空间的解释"><a href="#头文件、名称空间的解释" class="headerlink" title="头文件、名称空间的解释"></a>头文件、名称空间的解释</h3><p>头文件<code>#include&lt;bits/stdc++.h&gt;</code>包含了c++所有头文件；</p>
<h3 id="控制格式输入输出"><a href="#控制格式输入输出" class="headerlink" title="控制格式输入输出"></a>控制格式输入输出</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>setw()</code>/<code>cout.width()</code></td>
<td>输出数据的宽度</td>
</tr>
<tr>
<td><code>setfill()</code></td>
<td>设置填充字符</td>
</tr>
<tr>
<td><code>setiosflags()</code>/<code>resetiosflags()</code></td>
<td>对齐方式</td>
</tr>
<tr>
<td><code>setprecision()</code></td>
<td>输出数据的精度</td>
</tr>
<tr>
<td><code>setbase()</code></td>
<td>转换为某进制</td>
</tr>
</tbody></table>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="http://yoursite.com/2019/11/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ck3i59ovq0000tguyb37vdyff" class="article-share-link">Share</a>-->
      
      
    </footer>
  </div>
  
</article>


  


</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Mario<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> with 
      theme_by <a href="http://hexo.io/" target="_blank">mango</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives/" class="mobile-nav-link">Archives</a>
  
    <a href="/about/" class="mobile-nav-link">about</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>